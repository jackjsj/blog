---
sidebar: auto
---

# 前端面试题

## HTML

### SEO

### HTML5

## CSS

### BFC

### 层叠上下文

## Javascript

### 原型和原型链

1. 构建**函数**的 prototype->函数创建的**实例**的原型->实例的`__proto__`
2. 原型对象的 `constructor` 属性->构造函数本身
3. `Person.prototype === person1.__proto__`
4. 特点
   - 原型对象上添加属性，实例会共享这些属性
   - 在对象查找自身没有的属性时，会从对象的原型上找，找不到就找原型的原型，一直找到 Object.prototype，还找不到返回 null
5. 原型链就是查找对象查找属性时所途径的链式结构。

### 作用域和作用域链

1. 作用域：代码**定义变量**的区**域**。有一套**规则**，规定了**如何查找**变量，确定当前执行代码对变量的**访问权限**。
2. 分类：全局、函数和 eval 作用域。
3. 特点：JS 是**静态作用域**，函数的作用域在函数创建的时候就已确定。
4. 规则：作用域可**嵌套**，在查找变量时，先从当前作用域中查找，找不到就在外层的作用域中找，直至全局作用域，然后停止查找。
5. 作用域链：**逐层嵌套**的作用域构成的链表结构就是作用域链。

### 闭包

1.  怎么产生闭包
    - 函数嵌套，内函数引用了外函数的变量
2.  什么是闭包
    - 两种理解。
    - 内函数。
    - 包含引用变量的对象，chrome debugger scope 中的 closure。
3.  闭包的作用
    - 延长生命
    - 外部可用(突破作用域)
4.  闭包的缺点
    - 变量未释放->占内存
    - 滥用->内存泄漏

### this 的指向

1. 默认情况，非严格模式，this 指向全局对象
2. 在函数中 this 一般指向调用该函数的对象
3. 使用 call,apply,bind 方法可显式指定 this 的指向
4. 使用 new 调用构造函数，函数中的 this 指向新创建的实例对象
5. 箭头函数没有自己的 this，函数中的 this 指向箭头函数所在的上下文中的 this

### js 执行机制

1. 执行上下文
2. 执行上下文栈
3. 执行上下文如何创建？
   - 确定this指向
   - 创建词法环境
     - 环境记录
     - 对外部环境的引用
   - 创建变量环境

### js 中有哪些类型

答：8 种，undefined、null、number、string、boolean、symbol、bigInt、object。

### null 与 undefined 的区别

- undefined 表示变量声明了**未赋值**。
- null 赋值了，值为空，表示变量未来可能指向一个对象，可用于**主动释放** 对象的引用。

### == 和 === 的区别

- === 判断类型和值是否相同，对象比较的是地址值。
- == 类型相同，同===，不同会做隐式类型转换，具体判断流程如下：
  - 判断类型，相同则使用===，不相同，做类型转换
  - 判断是否对比 null 和 undefined，是就返回 true
  - 判断是否对比 string 和 number，是就将 string 转成 number 再比较
  - 判断其中一方是否为 boolean，是就将 boolean 转成 number 再比较
  - 判断其中一方是否为 object，且另一方为 string，number，symbol，是就把 object 转成原始类型。

### 为什么会有bigint提案

- js所有数字都保存成64位浮点数，这给数值的表示带来两大限制。
  - 一是数值的精度只能到53个二进制位（相当于16个十进制位），大于这个范围的整数，js无法精确表示，不适合科学和金融方面的精确计算。
  - 二是大于或等于2的1024次方的数值，js无法表示，会返回Infinity。
- bigInt就是用来解决这个问题的，只能用来表示整数，没有位数限制，任何位数的整数都能精确表示。为了与Number类型区别，bigInt必须添加后缀n。

### 为什么0.1+0.2!=0.3

- js中的数字是用64位二进制表示的
  - 其中第1位是符号位；
  - 2到12位，共11位是指数部分；
  - 第13到64位，共52位是小数部分，如果小数部分超过52位就会0舍1入保留52位，导致精度丢失。
- 0.1用二进制表示时，小数部分是1001无限循环，13次1001就占了52位，第53位是1，0舍1入舍去，最后4位最终会变成1010，这样肯定就比0.1大了。0.2也类似，最终相加实际比0.3大。

### 变量提升和函数提升

- 变量提升：var声明的变量，在声明前就可以访问，此时变量值为undefined。
- 函数提升：用function声明函数，在声明前就可以直接调用。
- 先执行变量提升，再执行函数提升。
- let和const有临时性区区的特性，必须声明才能使用，否则报错。

### ES6模块与CommonJS模块的区别

- 两大差异
  - CommonJS模块输出的是一个值的拷贝，加载模块后，在模块内改变值不会影响到输出值；ES6模块输出的是值的引用，模块内的输出值变了，会影响到引用它的地方。
  - CommonJS模块是运行时加载，ES6模块是编译时输出接口。

### V8 垃圾回收机制

- V8将内存堆分为新生代和老生代。
- 新生代中的对象存活时间较短，使用Scavenge算法。在新生代空间中，内存空间分为两部分，from空间和to空间。一个空间是使用的，另一个空间是空闲的。新分配的对象会被放入From空间中，当From空间占满时，新生代算法就会启动进行垃圾回收。该算法会检查from空间中存活的对象，判断对象是否符合晋升条件，如果符合就晋升成老生代，否则将对象复制到To空间中，如果有失活的对象就会销毁。当复制完成后将from空间和to空间互换，这样垃圾回收就结束了。
- 老生代中的对象存活时间较长，会使用两个算法，即**标记清除算法**和**标记压缩算法**。在Scavenge算法中，有些对象会因符合某些条件被移到老生代空间中，比如经历过一次Scavenge算法的对象，或者To空间对象占比大小超25%。
- 老生代中的**标记清除算法**故名思义，遍历堆中所有对象，将存活对象标记出来，然后对未标记的对象空间进行回收。
- 但经过标记清除后，会造成堆内存出现碎片的情况，当碎片超过一定限制后就会启动**标记压缩算法**，将活的对象向一端移动，直到所有对象都移动到一边，然后清理掉不需要的内存。

### 事件循环

- js 中有一个**主线程**，一个**调用栈**，和独立于调用栈的消息队列，可分宏任务队列和微任务队列
- 宏任务：script 代码，setTimeout/setInterval/setImmediate, I/O, UI rendering
- 微任务：process.nextTick, Promise, Object.observe, MutationObserver
- 代码执行过程中，将任务的各自回调函数根据任务类型放入对应的任务队列中
- 主执行栈清空，依次执行微任务队列中的任务，微任务队列清空后，再执行宏任务队列中的下一个任务

### JS异步方式

- 回调函数
- promise
- generator
- async/await

## Vue相关

### 虚拟DOM

- **本质**是用一个原生JS对象去**模拟**一个DOM节点，是对真实DOM的一层**抽象**。

- 为什么要用虚拟DOM？
  - 直接频繁操作DOM不好，表现在
    - JS操作DOM相对比较慢，JS引擎和渲染引擎是相互独立的，双方通信需要成本。
    - 频繁操作DOM会造成浏览器大量回流和重绘，消耗大量性能。
    - 省略手动操作DOM可以提高开发效率
  - 初衷是为了跨平台，nodejs环境中没有DOM，如果想实现服务端渲染（SSR），需要借助VDOM。

### diff算法（snabbdom.js）

- 将**虚拟DOM树同一级**的**新节点数组**与**旧节点数组**进行对比，并用**四个指针**分别指向这**两个数组**的**头尾**。

- 一直循环进行**头尾交叉对比**，直到两个数组中**任一数组**的**头指针超过尾指针** ，具体过程是:
  - 头头对比: 如相同把新节点patch到旧节点，头指针后移，否则继续
  - 尾尾对比: 如相同把新节点patch到旧节点，尾指针前移，否则继续
  - 旧尾新头对比: 如相同，把新节点patch到旧节点，旧尾指针前移，新头指针后移，否则继续
  - 旧头新尾对比: 如相同，把新节点patch到旧节点，新尾指针前移，旧头指针后移，否则继续
  - 利用key对比: 在旧节点数组中寻找新头指针指向的节点的key，这里**分三种**情况，
    - 没有对应的key，那创建新节点
    - 如果有对应key并且是相同的节点，把新节点patch到旧节点
    - 如果有对应key但是不是相同的节点，那也创建新节点

- 循环结束后，两个数组中可能存在没有遍历完的情况
  - 如新数组没遍历完，则添加新数组中漏掉的节点
  - 如旧数组没遍历完，则删除旧数组中漏掉的节点

### MVVM是什么

- 概述
  - MVVM是`Model-View-ViewModel`的缩写，分为三层
  - Model层主要是提供**数据模型**；
  - View层则是的提供**视图模板**，定义**结构布局**，展示**数据状态**，做了数据和事件的**绑定声明**，**指令声明**；
  - ViewModel是**View**和**Model**层的**桥梁**，数据绑定在ViewModel层会自动将数据渲染到页面，双向绑定的视图变化的时候也会通知ViewModel层更新数据。
- 优点
  - **分离**视图和模型，**降低**代码耦合，**提高**视图和逻辑复用
  - **双向绑定DOM**自动更新，开发者不用手动操作DOM
  - 便于**测试**
- 缺点
  - BUG难调试，双向绑定导致BUG**难以定位**错误发生在View层还是Model层。
  - 大型应用维护数据多，ViewModel构建维护成本会增大，Model层的数据长期持有也会大量占用内存。

### Vue的生命周期

- beforeCreate：当前阶段data、methods、computed以及watch上的数据和方法**都不可访问**。
- created：发生在实例创建后，这时候已**完成数据监测**，可**使用和获取**数据，但**无法与DOM交互**。
- beforeMount：发生在DOM挂载前，这时候**虚拟DOM已创建完成**，**即将开始渲染**。
- mounted：发生在DOM挂载后，数据**完成双向绑定**，**可访问DOM**。
- beforeUpdate：发生在响应式数据更新前，这时候虚拟DOM还没有重新渲染，还**可以更改数据**。
- updated：发生在数据更新后，**不能在此更改数据**，可能会导致**死循环**。
- beforeDestroy：发生在组件销毁前，可进行**收尾工作**，比如清除定时器。
- destroyed：发生在组件销毁后，只剩下DOM空壳，**数据绑定**和**监听**都被移除，**子组件**也被销毁。

### Vue的通信方式

1. `props/$emit+v-on`，通过props将数据自上而下传递，通过$emit和v-on向上传递；
2. 通过`EventBus`进行信息的发布订阅，利用vue实例的$emit和$on
3. 使用`vuex`，全局状态管理
4. 使用`$attrs/$listeners`，配置v-bind="$attrs"获取在父中定义的所有属性，配置v-on="$listeners"获取子中发布的所有事件
5. 使用`ref`可在父中访问子实例
6. 使用`$children/$parent`访问实例
7. 使用`provide/inject`，父通过provide提供变量，子通过inject注入变量，不管多深，但数据是非响应式的。
8. `localStorage/sessionStorage`

### computed和watch的区别

- computed是依赖于一个或多个属性，然后改变指定的属性值，有缓存性，只有依赖的属性发生改变才重新计算，常用于格式化数据
- watch是监听一个属性的变化而做一系列操作，比如要调ajax请求。

### Vue如何实现双向绑定的

- 采用**数据劫持**结合**发布订阅**模式，通过**Object.defineProperty()**来**劫持**数据对象各属性的**setter、getter**，在**数据变动**时**发布消息**给订阅者，**触发**相应监听**回调**。
- 具体实现
  - 实现一个数据监听器`Observer`，能够对数据对象各属性进行监听，如有变动获取最新值，通知订阅者；
  - 实现一个指令解析器`Compile`，对每个元素节点的指令进行扫描解析，根据指令模板替换数据，以及绑定相应的更新函数；
  - 实现一个`Watcher`，作为连接`Observer`和`Compile`的桥梁，能够订阅并收到属性变动通知，执行指令绑定的相应回调，从而更新视图；
  - 最后实现一个`MVVM`入口，用来接收数据对象，指定视图模板，调度`Observer`，`Compile`和`Watcher`。

### v-model的原理

- `v-model`本质是`value + input`方法的语法糖。可以通过model属性的`prop`和`event`属性来进行自定义。原生的v-model，会根据标签的不同生成不同的事件和属性。

### Vue事件绑定原理

- 原生事件绑定是通过`addEventListener`绑定给真实元素的，组件事件绑定是通过Vue自定义的`$on`实现的。

### Vue的模版编译原理

- Vue的编译过程就是将`template`转化为`render`函数的过程，主要分三步：
  1. 通过**解析器**，将**模板**转成**抽象语法树**（AST)；
  2. 通过**优化器**，对**AST**进行**静态节点标记**，主要用来做**虚拟DOM的渲染优化**；
  3. 通过**代码生成器**，将**AST**转成**render函数代码字符串**。

### Proxy相对于Object.defineProperty的优势

1. 可以直接监听**对象而非属性**，不用再遍历对象的属性
2. 可以直接监听**数组**的变化
3. 有多达**13**种拦截方法
4. 返回一个**新对象**，可以只操作新对象达到目的
5. 作为**新标准**，受到浏览器厂商重点持续的性能优化

### Vue中是如何检测数组变化

使用了**数据劫持**的方式，将数组操作的**7个方法**进行了**原型链重写**，指向了**自己定义**的数组方法，其实就是先调用了数组原本的方法，然后**添加通知依赖更新**的代码。这样当调用数组api时，就可以检测数组变化。如果数组中**包含**着**引用类型**，还会对数组中的引用类型**再次递归遍历**进行监控。

### Vue的key有什么用

- key是vue中虚拟DOM唯一标识，通过这个key，diff操作可以更准确，更快速。
- diff算法过程中，先会进行新旧节点的首尾交叉对比，当无法匹配的时候会用新节点的key与旧节点的key进行对比，然后查出差异。
- （准确）如果**不加key**，vue会选择**复用节点**，导致旧节点的**状态被保留**下来，产生一系列BUG
- （快速）key是唯一的，查找一个节点**不需要遍历**，因此更快速。

### nextTick的实现原理

在下次 DOM 更新循环结束之后执行延迟回调。nextTick主要使用了微任务，特殊情况会使用宏任务。根据执行环境分别尝试采用

- `Promise`(微)
- `MutationObserver`（微）
- `setImmediate`（宏）
- `MessageChannel`（宏）
- `如果以上都不行则采用setTimeout`（宏）

它定义了一个异步方法，多次调用nextTick会将方法存入队列中，通过这个异步方法清空当前队列。

### keep-alive的作用

- `keep-alive`可以实现组件**缓存**，当组件切换时**不会**对当前组件进行**卸载**。
- 常用的两个属性`include/exclude`，允许设置只对哪些组件进行缓存。
- 两个生命周期钩子`activated/deactivated`，分别在组件**激活**和**休眠**时触发。

### 怎么实现vue的mixin方法

### Vuex的原理

### Vue-Router的原理



## 手写与算法

### 实现类的继承

### 实现new

### 实现Object.create

### 实现instanceOf

### 实现call、apply和bind

### 实现防抖节流

### 实现deepClone

### 实现Promise

### 实现事件订阅发布

### 实现类型判断方法的封装 

### 排序算法

## 浏览器、HTTP和前端安全

### 浏览器渲染过程

### onload、DOMContentLoaded事件的触发顺序

1. 当onload事件触发时，页面上所有的DOM，样式表，脚本，图片等都已经加载好了。
2. 当DOMContentLoaded事件触发时，只有DOM加载完成。

### WEBSOCKET握手过程

### 前端安全问题

## 前端工程化和优化

### 首屏优化