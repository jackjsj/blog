---
sidebar: auto
---

# 前端面试题

## HTML

### SEO（搜索引擎优化，Search Engine Optimization）

前端需注意的SEO有：

- 合理使用`title`、`description`、`keywords`：这三项的**权重**逐个减小；
- **语义化**的`HTML`代码：让搜索引擎更容易理解网页；
- 重要的`HTML`代码要放在最前：搜索引擎抓取`HTML`顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容优先被抓取；
- 重要内容不要用`js`输出并且少用`iframe`：爬虫不会执行`js`，也不会抓取`iframe`中的内容；
- **非装饰性图片**必须加`alt`属性；
- 提高网站**速度**：网站速度是搜索引擎排序的一个重要指标

>记忆技巧：
>
>搜索引擎优化
>	搜
>		搜索3要素
>			title
>			description
>			keyword
>	索
>		说话
>			语义化
>				使用语义化标签，让搜索引擎更容易理解网页
>	引
>		引用
>			引用内容要从上到下
>				重要的HTML内容要放在前面
>					搜索引擎抓取HTML顺序是从上到下的
>					有的搜索引擎对抓取长度有限制
>					保证重要内容优先被抓取
>	擎
>		js引擎
>			重要内容不要用js输出
>				少用frame
>					搜索引擎不会执行js
>					不会抓取frame中的内容
>	优
>		速度优化
>			加载速度优化
>				在搜索引擎排序的一个重要指标
>	化
>		画
>			画图
>				图片
>					非装饰性图片必须加alt属性

### doctype的作用

- DOCTYPE是HTML的**标准声明**，必须声明在HTML文档**第一行**。它的作用是**告知**浏览器解析器用什么文档标准来解析页面。
- 有两种解析模式：标准模式和怪异模式。
  - 标准模式是使用**W3C**的标准解析渲染页面。
  - 怪异模式是用浏览器**自己的标准**解析渲染页面，不同浏览器看到的渲染结果不同，**不声明DOCTYPE就会使用怪异模式**。

### HTML、XML和XHTML的区别

- HTML是**超文本标记语言**，在HTML4.0**前先有实现后有标准**，导致HTML非常混乱和松散
- XML是可**扩展标记语言**，主要用来**存储数据**，可以扩展。
- XHTML是**可扩展超文本标记语言**，基于HTML和XML，W3C用它来解决HTML的混乱问题，并基于此诞生了**HTML5**，在开头加了DOCTYPE声明，开启标准模式。

### HTML5新特性

1. H5文档声明类型**仅有一型**，即`<!DOCTYPE HTML>`，**不再基于SGML**，不需要引用**DTD**
2. **新元素标签**，如**语义化标签**header, footer, section, nav, aside，**多媒体标签**video, audio, canvas
3. **input元素**添加了**新的类型**，如date, time, email等。
4. 添加了**新的技术**，如`WebWorker`、`Websocket`、`Geolocation`
5. **新增属性**和指定了**全域属性**, 比如meta标签的charset属性, script标签的defer和async属性，全域属性包括id, tabindex, repeat。
6. H5**移除**了一些元素，如big, center, font, frame等等

### 什么是HTML语义化

HTML语义化就是**使用适当语义**的HTML标签，让页面具有**良好的结构和含义**。

它的好处主要有两点：

1. 对开发者友好，**增强代码可读性**，**便于团队开发和维护**
2. 对机器友好，适合搜索引擎的**爬取有效信息**，**支持读屏软件**，**根据文档生成目录**等。

### 常用meta标签有哪些

meta标签用来**描述HTML文档元信息**，例如**描述**，**关键字**，**作者**，**日期时间**等。

常用的meta：

1. 比如`charset`，设置**文档字符编码**
2. `http-equiv`, 设置**http的响应头报文**，如设置http缓存过期时间
3. `viewport`，常用于**移动开发**，可以**控制视口的大小和比例**，用户是否可缩放视口等。

```html
<meta name="viewport" content="width=device-width，initial-scale=1，minimum-scale=1, maximum-scale=1，user-scalable=no">
<!-- 不缓存当前页面的设置 -->
<meta http-equiv=”pragma” content=”no-cache”>
<meta http-equiv=”cache-control” content=”no-cache”>
<meta http-equiv=”expires” content=”0″>
```

### src和href的区别

- src
  - 指向**外部资源的位置**；
  - 会将指向的内容**下载并会嵌入**到标签所在位置；
  - 当浏览器解析到这个元素时，**会暂停其它资源下载和处理**，直到资源加载、编译、执行完毕。（不一定准确，chrome中多个js资源的下载是并行的）
- href
  - 指向**网络资源的位置**
  - 用来**建立**当前元素与文档间的**链接**
  - 当浏览器识别到它指向的文件时，会并行下载资源，**不会停止对当前文档的处理**。

### img标签的title和alt有什么区别

- `title`是当鼠标悬浮在元素上的时候显示
- `alt`是的特有属性，是图片内容的等价描述，当图片无法加载时显示、可用于读屏器阅读图片，提高图片的访问性，非装饰性图片都必须设置有意义的值，有利于SEO。

### Canvas和SVG的区别

- `svg`绘制出来的每一个图形的元素都是独立的`DOM`节点，而`canvas`输出的是一整幅画布。
- `svg`输出的图形是矢量图形，能修改参数自由放大缩小，不会失真。而`canvas`输出的画布就像一张图片，放大时会失真。

### script标签的defer和async的区别

- 默认遇到script标签会停止HTML解析，等待脚本**加载执行完毕**后，才继续解析文档。
- 加async属性，脚本会**异步加载**，加载完后立即执行，阻塞HTML解析，而且不能保证脚本执行顺序
- 加defer属性，脚本也会异步加载，但不会立即执行，会等到HTML解析完成后再执行，能保证脚本执行顺序。

### 前端存储方式

有五种存储方式，分别是cookie, localStorage, sessionStorage, indexDB, webSQL。

1. cookie的优点就是兼容性好，使用方便。缺点是大小只有4KB，请求头自带cookie浪费流量，每个domain的cookie个数有限制。
2. localStorage和sessionStorage差不多，一个是永久存储，除非手动删除，一个是会话级存储，即页面关闭数据就没了。
3. indexedDB是H5的数据库储存方案，允许存大容量数据，用key-value进行存储，用JS操作方便
4. webSQL已被W3C废弃，属于关系型数据库，用SQL操作，较为繁琐，用得较少。

## CSS

### CSS选择器优先级

- 内联>id>class>tag

### link和@import的区别

1. link是标签，可以用DOM操作，@import是CSS提供的，不能用DOM操作。
2. link引入的资源会在页面加载时加载，而@import引用的CSS会等到页面加载完才加载
3. link无兼容问题，@import只在IE5以上才能识别

### CSS隐藏元素的方式和区别

- display:none: 不占空间，不可交互
- visibility:hidden：占空间，不可交互
- opacity:0：占空间，可交互
- transform:scale(0,0)：占空间，不可交互

### CSS有几种定位方式

- 五种，分别是static\relative\absolute\fixed\sticky
- sticky是relative和fixed的结合体，在屏幕范围内同relative，要滚出屏幕时就和fixed一样

### 盒模型

标准盒模型和IE盒模型，标准盒模型的宽高就是内容的宽度，而IE盒模型的宽高是内容+内边距+边框后的结果。

### 伪元素和伪类

- 伪元素是不存在于文档树中的元素，通过给它添加样式来实现一些效果，如before,after
- 伪类表示元素的某种特定状态，如active, hover

### BFC

- BFC**块级格式化上下文**，是页面中一块**独立的渲染区域**，有一些**渲染规则和特性**，**决定了**它的**子元素**如何布局，它**内部**的元素与**外部**的元素**相互隔离，互不影响**。
- 符合一些**条件**就可以触发BFC：
  - **根**元素
  - **浮动**元素
  - position为**absolute或fixed**的元素
  - **overflow不为visible**的元素
  - display为`inline-block\table\table-cell\table-caption\flex\inline-flex\grid\inline-grid`的元素等
- BFC有一些**特性**，比如：
  - BFC内部盒子会在垂直方向**一个接一个**地排列
  - BFC内部盒子**垂直方向的距离**由外边距决定，同属一个BFC的相邻盒子**垂直外边距**会重叠
  - BFC内部盒子的margin左边与包含块border左边**相接触**，即使存在浮动也是如此
  - BFC区域不会与**其它浮动盒子**发生重叠
  - BFC**计算高度**的时候，浮动盒子也参与计算

- 根据这些特征，我们常用BFC来
  - 实现**双栏**自适应布局
  - **清除浮动**
  - 解决**外边距塌陷**问题

> 记忆技巧
>
> 特性
> 	1
> 		一个接一个
> 			BFC内部盒子在垂直方向一个接一个的排列
> 	2
> 		垂直
> 			BFC内部盒子垂直方向的距离由外边距决定
> 			垂直方向外边距会重叠
> 	3
> 		三
> 			三根线都不接触
> 				接触
> 					BFC内部盒子的margin左边和包含盒子的border左边相接触，即使存在浮动也是如此
> 	4
> 		私服
> 			浮动
> 				BFC不与其它浮动盒子相重叠
> 	5
> 		呜呜呜
> 			哭泣的声音很高
> 				BFC计算高度时，浮动盒子也参与计算

### 媒体查询

- 媒体查询是网页对**不同型号设备**做出**适配**的**响应式设计方案**。
- 媒体查询包括
  - 可选的媒体类型
  - 若干表达式，这些表达式描述了媒体特征，如果满足这些特征，媒体查询内的样式就会被使用。

### z-index和层叠上下文

- **层叠上下文**是一个**三维概念**，如果一个元素是层叠上下文元素，那么这个元素在Z轴上就“高人一等”。
- **层叠水平**，决定了同一层叠上下文中元素在Z轴的显示顺序，普通元素的层叠水平优先由层叠上下文决定，层叠水平的比较只有在当前层叠上下文元素中才有意义
- **层叠顺序**，表示元素在发生叠时候有着特定的垂直显示顺序。
  - 层叠上下文的border和background
  - 负的z-index元素

  - block块级元素

  - float元素

  - inline/inline-block元素

  - z-index为auto或为0的元素

  - 正的z-index元素
- 元素符合一些条件可以**创建**层叠上下文：

  - html**根**元素
  - **z-index不是auto的定位**元素
  - **flex项目**元素
  - 设置了一些css3属性的元素
    - **opacity**小于1
    - **transform/filter/perspective**不为none的元素
- 它有一些**特性**：

  - 每个层叠上下文**自成一体**，**整个元素**在**父层叠上下文中的顺序**中。
  - 每个层叠上下文**和兄弟元素**相互独立
  - 层叠上下文**可以嵌套**，**内部**层叠上下文**和它的子元素**都**受制于**外部的层叠上下文

> 特性
> 	1
> 		自成一体
> 			在父叠层上下文中的顺序中
> 	2
> 		两兄弟
> 			和兄弟之前相互独立
> 	3
> 		3同山
> 			嵌套
> 				层叠上下文可以嵌套，内部层叠上下文和它的子元素受制于外部的层叠上下文

## Javascript

### 原型和原型链

1. 几乎所有**函数**都有一个prototype属性，它会指向这个函数创建的**实例对象**的原型
2. **实例对象**也会有一个`__proto__`属性指向自己的隐式原型。(`Person.prototype === person.__proto__`)
3. 原型是个对象，它有一个 `constructor` 属性指向构造函数本身
4. 原型有以下特点：
   - 原型对象上添加属性，所有实例都会共享这些属性
   - 在对象上查找自身没有的属性时，会从对象的原型上找，找不到就找原型的原型，一直找到 Object.prototype，找不到就返回undefined
5. 原型链就是查找对象属性时所形成的链式结构。

### 作用域和作用域链

1. 代码**定义变量**的区域，它规定了**如何查找**变量，确定当前执行代码对变量的**访问权限**。
2. 根据代码所在的位置可分为：全局、函数和 eval 作用域。
3. JS 是**静态作用域**，函数的作用域在函数创建的时候就已确定。
4. 作用域可**嵌套**，在查找变量时，先从当前作用域中查找，找不到就在外层的作用域中找，一直找到全局作用域，找不到就报错。
5. **逐层嵌套**的作用域形成的链式结构就是作用域链。

### 闭包

1.  函数嵌套，内部函数引用了外部函数的变量，这样就能产生闭包；
2.  闭包有两种理解：
    - 这个内部函数就是闭包
    - 闭包是包含引用变量的对象，谷歌浏览器debugger时可以看到这个closure对象。
3.  闭包的作用
    - 延长了引用变量的生命周期
    - 让外部可以使用函数内部的变量，突破了作用域的限制
4.  闭包的缺点
    - 变量未释放会占用内存
    - 滥用闭包会导致内存泄漏

### this 的指向

1. 默认情况，非严格模式，this 指向全局对象
2. 在函数中 this 一般指向调用该函数的对象
3. 使用 call,apply,bind 方法可显式指定 this 的指向
4. 使用 new 调用构造函数，函数中的 this 指向新创建的实例对象
5. 箭头函数没有自己的 this，函数中的 this 指向箭头函数所在的上下文中的 this

### js 执行机制

一段JS代码的运行可分为两个阶段：

- 编译阶段，先进行分词/词法分析，再进行解析/语法分析，最后进行预编译
- 执行阶段，js代码并非简单的一行行解释执行的，而是将js代码分为一块块的可执行代码块进行执行，可分为三类，分别是
  - 全局代码块
  - 函数代码块
  - eval代码块

JS引擎由两个主要部分组成：

- 内存堆：是内存分配地址的地方
- 调用栈：是代码执行地方

在代码块执行前会先创建执行上下文，三种代码块会对应三种执行上下文，分别是全局、函数和eval执行上下文。

- 全局执行上下文，任何不在函数内部的代码都在全局上下文中，一个程序只有一个全局上下文，它会执行两件事：
  - 创建一个全局的window对象
  - 设置this的值等于这个全局对象
- 函数执行上下文，每当一个函数被调用时，都会为这个函数创建一个新的执行上下文。
- 在执行eval内部的代码时也会创建它自己的执行上下文。

> 在js引擎首次读取代码时，会创建一个全局执行上下文并将其推入当前的执行栈。每当发生一个函数调用，引擎都会为该函数创建一个新的执行上下文并将其推到当前执行栈顶端。引擎会运行执行上下文栈顶端的函数，当此函数运行完成后，其对应的上下文将会从执行栈中弹出。最终执行栈中的上下文会被清空，这时所有代码执行完毕。

执行上下文的创建可分为两个阶段：

- 创建阶段，主要做一些准备工作
- 执行阶段，主要工作就是给变量赋值

创建阶段做的准备工作包括三点：

- 决定this的指向
- 创建词法环境
- 创建变量环境

词法环境包括两个部分，环境记录器和外部环境的引用

- 环境记录器是存储变量和函数声明的实际位置
- 外部环境的引用是指它可以访问其父级词法环境，也就是作用域。

词法环境分三大类：

- 全局环境，全局环境的外部引用是null，它拥有全局对象，比如window对象，还有用户定义的全局变量，并且this值指向全局对象。
- 模块环境，包含模块顶级声明的绑定以及模块显式导入的绑定，模块环境的外部引用是全局环境。
- 函数环境，函数内部用户定义的变量存储在环境记录器中，外部引用既可以是其它函数的内部词法环境，也可以是全局环境

变量环境也是一个词法环境，不同的是词法环境用来存储函数声明和变量（let和const)的绑定，而变量环境只用来存储var变量绑定。

### null 与 undefined 的区别

- `undefined`表示变量**声明了，未赋值**。
- `null`表示**赋值了，值为空**，将变量赋值为null可用来**主动释放**对象的引用。

### == 和 === 的区别

- === 判断类型和值是否相同，对象类型比较的是内存地址值。
- 用==判断时，如类型相同，会去使用===判断，如类型不同会做隐式类型转换，具体判断流程如下：
  - 判断是否对比` null `和 `undefined`，是就返回 true
  - 判断是否对比 `string `和 `number`，是就将 string 转成 number 再比较
  - 判断其中一方是否为` boolean`，是就将 boolean 转成 number 再比较
  - 判断其中一方是否为 `object`，且另一方为 string，number，symbol，是就把 object 转成原始类型。

### 为什么会有bigint提案

- js所有数字都保存成64位浮点数，这给数值的表示带来两大限制。
  - 一是数值的精度只能到53个二进制位（相当于16个十进制位），大于这个范围的整数，**无法精确表示**，不适合**科学金融**方面的精确计算。
  - 二是大于或等于2的1024次方的数值，**无法表示**，会返回**Infinity**。
- bigInt就是用来解决这个问题的，**只能表示整数**，**没有位数限制**，任何位数的整数都能精确表示。为了与Number类型区别，bigInt必须添加后缀n。

### 为什么0.1+0.2!=0.3

- js中的数字是用64位二进制表示的
  - 其中第1位是符号位；
  - 2到12位，共11位是指数部分；
  - 第13到64位，共52位是小数部分，如果小数部分超过52位，就会丢失精度。
- 0.1用二进制表示时，小数部分是1001无限循环，13次1001就占了52位，第53位是1，0舍1入舍去，最后4位最终会变成1010，这样肯定就比0.1大了。0.2也类似，最终相加实际比0.3大。

### 变量提升和函数提升

- 变量提升：var声明的变量，在声明前就可以访问，此时变量值为undefined。
- 函数提升：用function声明函数，在声明前就可以直接调用。
- **函数提升>变量提升**，且被变量声明覆盖，但会被变量赋值之后覆盖。
- **形参赋值在前，变量提升在后**
- 在if判断里声明的var和function都只声明，不赋值，只要进到当前if条件中，会立即对fn进行赋值，这种现象发生成ES6以后
  - 因为ES6中if\for\while的{}被解析成块级作用域
- return下面的代码进行变量提升，提return后面的不进行变量提升
- let和const有**临时死区**的特性，必须声明才能使用，否则报错。

### ES6模块与CommonJS模块的区别

- CommonJS模块输出的是一个值的拷贝，加载模块后，在模块内改变值不会影响到输出值；ES6模块输出的是值的引用，模块内的输出值变了，会影响到引用它的地方。
- CommonJS模块是运行时加载，ES6模块是编译时输出接口。

### V8 垃圾回收机制

- V8将内存堆分为两个空间：**新生代**和**老生代**，新生代中的对象存活时间较短，老生代中的对象存活时间较长。
- 在新生代空间中，内存空间又分为**两部分**，f**rom空间和to空间**。一个空间是**使用的**，另一个空间是**空闲的**。新分配的对象会被放入From空间中，当From空间占满时，就会启动Scavenge算法进行垃圾回收。该算法会检查from空间中存活的对象，判断对象是否符合晋升条件，如果符合就晋升成老生代，否则将对象复制到To空间中，如果有失活的对象就会销毁。当复制完成后将from空间和to空间互换，这样垃圾回收就结束了。
- 老生代空间会使用两个算法，**标记清除算法**和**标记压缩算法**。
- **标记清除算法**就是遍历堆中所有对象，将存活对象标记出来，然后对**未标记的对象空间**进行**回收**。
- 但经过标记清除后，会造成堆内存**出现碎片**的情况，当**碎片超过一定限制**后就会启动**标记压缩算法**，将活的对象向一端移动，直到所有对象都移动到一边，然后清理掉不需要的内存。

### 事件循环

事件循环是解决js单线程运行时不会阻塞的一种机制。

首先在我们JS中，有一个主线程，主线程中有一个调用栈，在调用栈中执行我们的同步代码。

当我们的代码中有setTimeout, setInterval 或 ajax 等异步操作的时候，这些异步任务不会在主线程中执行，而是js引擎将他们交给对应的定时器触发线程或HTTP请求线程去执行，然后这些线程处理完毕后，会将回调函数按顺序放到一个任务队列当中。

当调用栈中的代码全部执行完毕后，js引擎才会去任务队列中找有没有异步任务，如果有就依次将它们放入调用栈中执行，这个过程是循环不断的。

实际上，任务队列分成宏任务队列和微任务队列。

- 宏任务：script 代码，setTimeout/setInterval/setImmediate, I/O
- 微任务：Promise, MutationObserver，process.nextTick

JS引擎一开始会在调用栈中执行一个宏任务，也就是script代码，执行过程中可能会产生新的宏任务和微任务，分别将他们放入对应的任务队列中，当调用栈中的代码被执行完以后，会查看微任务队列中是否有微任务，如果有就执行所有的微任务，这样就完成一轮事件循环，如还有宏任务，则执行新的宏任务，开启下一轮循环。

### JS异步编程方式

- 回调函数
- 事件监听
- 发布订阅
- Promise
  - Promise是ES6新增的语法，是异步编程的一种解决方案，解决了传统回调函数方式的地狱回调的问题。
  - Promise是一个构造函数，接受一个方法，方法有两个参数，分别是resolve和reject，通过构造函数可以创建Promise实例
  - 一个Promise实例对象有三种状态，初始为pending状态，可以通过resolve和reject函数将状态转变为resolved和rejected状态，状态一旦改变就不能再次改变。
  - promise实例对象还有一个then方法，方法接受一个回调方法，当状态从pending变为resolved或rejected后，就会执行then中的这个回调方法，他的返回值是一个新的promise实例
- Generator
  - Generator是ES6中新增的语法，也是异步编程的解决方案。
  - 声明函数时在函数名前加*号，就可以声明一个Generator函数，函数内使用yield表达式，定义不同的内部状态，执行该函数会返回一个遍历器对象。
  - 这个遍历器对象代表Generator函数的内部指针，每次调用遍历器对象的next方法，会返回一个有value和done两个属性的对象。
  - value属性表示当前内部状态的值，是yield表达式后面那个表达式的值；done属性是一个boolean，表示是否遍历结束
- async/await
  - 是Generator函数的语法糖，Generator函数的执行需要执行器，async函数自带执行器
  - async 声明一个异步函数，其返回值是一个Promise对象，只有在async函数内部异步操作执行完，才会执行then方法指定的回调，内部可使用await
  - await只能在async声明的函数中使用，放在Promise对象前，后面的代码会等到Promise完成并返回结果后才执行。
  - 优势
    - 同步的写法更加优雅，不仅解决了回调地狱问题，还省去了then的链式调用所带来的阅读负担
    - 处理错误的方式更加友好，可以用try/catch方式，而不是Promise的错误捕获方式
    - 调试更加方便

## Vue相关

### 虚拟DOM

- **本质**是用一个原生JS对象去**模拟**一个DOM节点，是对真实DOM的一层**抽象**。

- 为什么要用虚拟DOM？
  - 直接频繁操作DOM不好，表现在
    - JS操作DOM相对比较慢，JS引擎和渲染引擎是相互独立的，双方通信需要成本。
    - 频繁操作DOM会造成浏览器大量回流和重绘，消耗大量性能。
    - 省略手动操作DOM可以提高开发效率
  - 初衷是为了跨平台，nodejs环境中没有DOM，如果想实现服务端渲染（SSR），需要借助VDOM。

### diff算法（snabbdom.js）

- 将**虚拟DOM树同一级**的**新节点数组**与**旧节点数组**进行对比，并用**四个指针**分别指向这**两个数组**的**头尾**。

- 一直循环进行**头尾交叉对比**，直到两个数组中**任一数组**的**头指针超过尾指针** ，具体过程是:
  - 头头对比: 如相同把新节点patch到旧节点，头指针后移，否则继续
  - 尾尾对比: 如相同把新节点patch到旧节点，尾指针前移，否则继续
  - 旧尾新头对比: 如相同，把新节点patch到旧节点，旧尾指针前移，新头指针后移，否则继续
  - 旧头新尾对比: 如相同，把新节点patch到旧节点，新尾指针前移，旧头指针后移，否则继续
  - 利用key对比: 在旧节点数组中寻找新头指针指向的节点的key，这里**分三种**情况，
    - 没有对应的key，那创建新节点
    - 如果有对应key并且是相同的节点，把新节点patch到旧节点
    - 如果有对应key但是不是相同的节点，那也创建新节点

- 循环结束后，两个数组中可能存在没有遍历完的情况
  - 如新数组没遍历完，则添加新数组中漏掉的节点
  - 如旧数组没遍历完，则删除旧数组中漏掉的节点

### MVVM是什么

- 概述
  - MVVM是`Model-View-ViewModel`的缩写，分为三层
  - Model层主要是提供**数据模型**；
  - View层则是的提供**视图模板**，定义**结构布局**，展示**数据状态**，做了数据和事件的**绑定声明**，**指令声明**；
  - ViewModel是**View**和**Model**层的**桥梁**，数据绑定在ViewModel层会自动将数据渲染到页面，双向绑定的视图变化的时候也会通知ViewModel层更新数据。
- 优点
  - **分离**视图和模型，**降低**代码耦合，**提高**视图和逻辑复用
  - **双向绑定DOM**自动更新，开发者不用手动操作DOM
  - 便于**测试**
- 缺点
  - BUG难调试，双向绑定导致BUG**难以定位**错误发生在View层还是Model层。
  - 大型应用维护数据多，ViewModel构建维护成本会增大，Model层的数据长期持有也会大量占用内存。

### Vue的生命周期

- beforeCreate：当前阶段data、methods、computed以及watch上的数据和方法**都不可访问**。
- created：发生在实例创建后，这时候已**完成数据监测**，可**使用和获取**数据，但**无法与DOM交互**。
- beforeMount：发生在DOM挂载前，这时候**虚拟DOM已创建完成**，**即将开始渲染**。
- mounted：发生在DOM挂载后，数据**完成双向绑定**，**可访问DOM**。
- beforeUpdate：发生在响应式数据更新前，这时候虚拟DOM还没有重新渲染，还**可以更改数据**。
- updated：发生在数据更新后，**不能在此更改数据**，可能会导致**死循环**。
- beforeDestroy：发生在组件销毁前，可进行**收尾工作**，比如清除定时器。
- destroyed：发生在组件销毁后，只剩下DOM空壳，**数据绑定**和**监听**都被移除，**子组件**也被销毁。

### Vue的通信方式

1. `props/$emit+v-on`，通过props将数据自上而下传递，通过$emit和v-on向上传递；
2. 通过`EventBus`进行信息的发布订阅，利用vue实例的$emit和$on
3. 使用`vuex`，全局状态管理
4. 使用`$attrs/$listeners`，配置v-bind="$attrs"获取在父中定义的所有属性，配置v-on="$listeners"获取子中发布的所有事件
5. 使用`ref`可在父中访问子实例
6. 使用`$children/$parent`访问实例
7. 使用`provide/inject`，父通过provide提供变量，子通过inject注入变量，不管多深，但数据是非响应式的。
8. `localStorage/sessionStorage`

### computed和watch的区别

- computed是依赖于一个或多个属性，然后改变指定的属性值，有缓存性，只有依赖的属性发生改变才重新计算，常用于格式化数据
- watch是监听一个属性的变化而做一系列操作，比如要调ajax请求。

### Vue如何实现双向绑定的

- 采用**数据劫持**结合**发布订阅**模式，通过**Object.defineProperty()**来**劫持**数据对象各属性的**setter、getter**，在**数据变动**时**发布消息**给订阅者，**触发**相应监听**回调**。
- 具体实现
  - 实现一个数据监听器`Observer`，能够对数据对象各属性进行监听，如有变动获取最新值，通知订阅者；
  - 实现一个指令解析器`Compile`，对每个元素节点的指令进行扫描解析，根据指令模板替换数据，以及绑定相应的更新函数；
  - 实现一个`Watcher`，作为连接`Observer`和`Compile`的桥梁，能够订阅并收到属性变动通知，执行指令绑定的相应回调，从而更新视图；
  - 最后实现一个`MVVM`入口，用来接收数据对象，指定视图模板，调度`Observer`，`Compile`和`Watcher`。

### v-model的原理

- `v-model`本质是`value + input`方法的语法糖。可以通过model属性的`prop`和`event`属性来进行自定义。原生的v-model，会根据标签的不同生成不同的事件和属性。

### Vue事件绑定原理

- 原生事件绑定是通过`addEventListener`绑定给真实元素的，组件事件绑定是通过Vue自定义的`$on`实现的。

### Vue的模版编译原理

- Vue的编译过程就是将`template`转化为`render`函数的过程，主要分三步：
  1. 通过**解析器**，将**模板**转成**抽象语法树**（AST)；
  2. 通过**优化器**，对**AST**进行**静态节点标记**，主要用来做**虚拟DOM的渲染优化**；
  3. 通过**代码生成器**，将**AST**转成**render函数代码字符串**。

### Proxy相对于Object.defineProperty的优势

1. 可以直接监听**对象而非属性**，不用再遍历对象的属性
2. 可以直接监听**数组**的变化
3. 有多达**13**种拦截方法
4. 返回一个**新对象**，可以只操作新对象达到目的
5. 作为**新标准**，受到浏览器厂商重点持续的性能优化

### Vue中是如何检测数组变化

使用了**数据劫持**的方式，将数组操作的**7个方法**进行了**原型链重写**，指向了**自己定义**的数组方法，其实就是先调用了数组原本的方法，然后**添加通知依赖更新**的代码。这样当调用数组api时，就可以检测数组变化。如果数组中**包含**着**引用类型**，还会对数组中的引用类型**再次递归遍历**进行监控。

### Vue的key有什么用

- key是vue中虚拟DOM唯一标识，通过这个key，diff操作可以更准确，更快速。
- diff算法过程中，先会进行新旧节点的首尾交叉对比，当无法匹配的时候会用新节点的key与旧节点的key进行对比，然后查出差异。
- （准确）如果**不加key**，vue会选择**复用节点**，导致旧节点的**状态被保留**下来，产生一系列BUG
- （快速）key是唯一的，查找一个节点**不需要遍历**，因此更快速。

### nextTick的实现原理

在下次 DOM 更新循环结束之后执行延迟回调。nextTick主要使用了微任务，特殊情况会使用宏任务。根据执行环境分别尝试采用

- `Promise`(微)
- `MutationObserver`（微）
- `setImmediate`（宏）
- `MessageChannel`（宏）
- `如果以上都不行则采用setTimeout`（宏）

它定义了一个异步方法，多次调用nextTick会将方法存入队列中，通过这个异步方法清空当前队列。

### keep-alive的作用

- `keep-alive`可以实现组件**缓存**，当组件切换时**不会**对当前组件进行**卸载**。
- 常用的两个属性`include/exclude`，允许设置只对哪些组件进行缓存。
- 两个生命周期钩子`activated/deactivated`，分别在组件**激活**和**休眠**时触发。

### Vuex的原理

### Vue-Router的原理



## 手写与算法

### 实现类的继承

- 子类通过借用构造函数`Parent.call()`继承属性
- 通过原型链`Child.prototype = Object.create(Parent.prototype)`继承父类的方法
- 重新设置子类的构造函数`Child.prototype.Constuctor = Child`

### 实现new

- 创建一个空对象
- 让对象的`__proto__`指向构造函数的prototype属性
- 绑定this的指向并执行构造函数
- 判断返回值是不是对象，如果是对象就返回，不是就返回当前this

### 实现Object.create

- 创建一个函数
- 让函数的prototype属性指向方法的第一个实参
- 返回这个构造函数的一个实例

### 实现instanceOf

- 思路：左边是实例对象，右边是构造函数，循环遍历左边的隐式原型链上的原型是否有右边的显式原型，没有则返回false，有就返回true

### 实现call、apply和bind

- call
  - 函数对象的原型方法
  - 在第一个参数上添加一个属性，属性值为函数对象
  - 获取后面的参数，当作实参传入函数并执行得到返回值
- apply
  - 同call，只是只有两个参数，第二个参数是类数组
- bind
  - 返回一个方法
  - 

### 实现防抖节流

- 防抖和节流都是限制事件触发回调在一段时间以后才能再次执行的方式；
- 区别在于防抖是从上一次触发事件的时间开始计时，而节流是从上一次执行回调方法的时间开始计时。

### 实现deepClone

### 实现Promise

### 实现事件订阅发布

### 排序算法

- 冒泡排序
  - 时间复杂度：O(n^2)
  - 思路：
    - 相邻两个数从左到右依次对比，左数大于右数，则交换位置；
    - 这样对比完一轮，最大的数在最右边；
    - 一直这样对比N轮，N为数组长度-1
- 快速排序
  - 时间复杂度：O(nlogn)
  - 思路：
    - 在数组中取一个基准值Pivot，可以取数组中间那个数
    - 数组头和尾各放一个指针，将指针指向的数与基准值对比，头指针小于基准值则向右移动，尾指针大于基准值则向左移动，直到头指针位置超过尾指针就停止移动
    - 过程中如果有头指针指向的数大于基准值且尾指针指向的数小于基准值，就交换头尾指针指向的两个数的位置
    - 当指针停止后，记录头指针的位置，以这个位置为准将数组分为两部分，然后分别对这两部分执行1到3步骤，直到数组的元素个数小于等于1
    - 然后把数组再合并起来
- 插入排序
  - 时间复杂度：O(n^2)
  - 思路：同打扑克抓牌理牌的方式
- 归并排序
  - 时间复杂度：O(nlogn)
  - 思路：同比赛中产生4强的方式

## 浏览器、HTTP和前端安全

### 从浏览器地址栏输入url到显示页面的步骤

1. 浏览器查看缓存，如果请求资源在缓存中并且新鲜，直接进行文件转码解析
2. 如果资源没有缓存，或者缓存已过期，则解析URL获取协议，主机，端口号和path，组装成一个HTTP GET请求报文
3. 对主机域名做DNS解析，将其解析成IP地址，这个过程会先去找DNS缓存
   1. 浏览器DNS缓存
   2. 本机DNS缓存
   3. hosts文件
   4. 路由器DNS
   5. ISP的DNS服务器
   6. 根服务器递归查询
4. 接着是建立TCP连接，进行三次握手
5. TCP连接成功后，发送HTTP请求
6. 服务器接收到HTTP请求后，经后端程序处理，完成后向客户端返回一个HTTP响应
7. 浏览器接收到响应后，首先会判断状态码是什么，如果是 200 那就继续解析，如果 400 或 500 的话就会报错，如果 300 的话会进行重定向，这里会有个重定向计数器，避免过多次的重定向，超过次数也会报错
8. 浏览器开始解析文件，如果是 gzip 格式的话会先解压一下
9. 然后通过文件的编码格式解码文件
10. 文件解码成功后，正式开始渲染流程，解析HTML构建 DOM 树，与此同时解析CSS构建 CSSOM 树。
11. 如果遇到 `script` 标签的话，默认会阻塞渲染流程，直到JS解析执行完毕，如果存在 `async` 或者 `defer`属性 ，async会并行下载，下载完后立即执行脚本，后者也会并行下载文件，但不会立即执行，会等到HTML解析完成后顺序执行。
12. DOM树和CSSOM树构建完成后会合成 Render 树。
13. 接着进入布局阶段（**Layout**），为每个节点**分配**一个**应出现在屏幕上**的**确切坐标**。
14. 随后调用**GPU进行绘制**，遍历Render Tree的节点，将元素呈现出来。

### 浏览器渲染过程

1. 浏览器获取HTML文件，然后解析，形成**DOM Tree**
2. 与此同时，进行CSS解析，生成CSS对象模型（**CSSOM Tree**）
3. 接着将Dom Tree与CSSOM Tree**合成为Render Tree**
4. 接着进入布局阶段（**Layout**)，为每个节点分配一个应出现在屏幕上的确切坐标
5. 随后调用**GPU进行绘制**，遍历Render Tree的节点，并将元素呈现出来

### DOM Tree是如何构建的

1. 转码：**浏览器**将接收到的**二进制数据**按照**指定编码格式**转化为**HTML字符串**
2. 生成Tokens：浏览器**渲染引擎**将HTML字符串解析成**Tokens**
3. 构建Nodes：对Node**添加特定属性**，通过**指针确定**Node的父、子、兄弟**关系**和**所属treeScope**
4. 生成Dom Tree：通过node包含的**指针**确定的**关系**构建出**DOM Tree**

### onload、DOMContentLoaded事件的触发顺序

1. 当onload事件触发时，页面上所有的DOM，样式表，脚本，图片等都已经加载好了。
2. 当DOMContentLoaded事件触发时，只有DOM加载完成。

### 浏览器回流和重绘的区别

- 重排：部分**渲染树**（或者整个渲染树）需要**重新分析**并且**节点尺寸需要重新计算**，表现为重新生成布局，重新排列元素
- 重绘：节点的**几何属性**发生改变，表现为某些元素的**外观被改变**。

### 什么是同源策略，如何实现跨域

- 同源是指“协议+域名+端口”三者相同，两个不同域名指向同一IP也属于非同源。
- 同源策略是一种约定，它是浏览器的安全基石，如果缺少了同源策略的限制，浏览器很容易遭受XSS、CSRF等攻击。
- 有三个标签不受同源策略限制：
  - img标签
  - link标签
  - script标签
- 如何实现跨域
  - JSONP
  - CORS
  - 服务器代理

### 实现即时通讯的方式

1. 短轮询
2. comet技术
3. Server Send Event
4. WebSocket

### CDN的原理



### 什么是HTTP

HTTP是超文本传输协议（Hyper Text Transfer Protocol）是一种通信协议，它允许将超文本标记语言（HTML)文档从WEB服务器传送到客户端的浏览器。HTTP协议是构建在TCP/IP协议之上的，是TCP/IP协议的一个子集。

### HTTP有哪些方法

1. GET， 获取资源
2. POST ，发送数据
3. OPTIONS， 查看资源支持什么方法请求
4. HEAD， 获取请求资源的头部信息，如在下载大文件前先获取大小，再决定是否下载
5. PUT， 新增或更新资源
6. DELETE，删除资源
7. PATCH，局部修改资源
8. CONNECT， 把请求连接转换成透明的TCP/IP通道
9. TRACE， 用来激发一个远程的应用层的请求消息回路

### GET/POST POST/PUT PUT/PATCH的区别

- GET/POST区别：
  - 数据传输方式不同
  - 安全性不同
  - 数据类型不同
  - 特性不同
- PUT/POST区别：PUT是更新资源PUT幂等，POST是提交资源POST非幂等
- PUT/PATCH的区别：都是更新资源，PATCH可对资源进行局部更新

### HTTP报文

- 请求报文：
  - 请求行，包括请求方法，URL和HTTP协议版本号
  - 请求头，由键值对组成，每行一对，冒号分隔
  - 空行
  - 请求体，post put等方法携带的数据
- 响应报文
  - 响应行，包括HTTP协议版本，状态码和状态码短语
  - 响应头，由键值对组成，每行一对，冒号分隔
  - 空行
  - 响应体，服务器返回的数据

### HTTP首部

- 通用首部

  - 通用信息性首部字段

    - Connection

      -  控制不再转发给代理的首部字段（即逐跳首部），应用程序会删除报文中所有在Connection首部中出现过的首部，如下示例

        ```
        # 客户端请求首部
        GET / HTTP1.1
        Upgrade:WebSocket
        Connection:Upgrade
        
        # 经过代理服务器后发送给Web服务器的首部
        GET / HTTP1.1
        ```

      - 管理持久连接

        - Connection:close , HTTP/1.1 默认都是持久连接，使用close后会明确断开连接
        - Connection:keep-alive, HTTP/1.1之前的版本默认都是非持久连接，使用keep-alive可以开启持久连接。

    - Warning: 错误和警告通知

    - Upgrade: 升级为其它协议

    - Date: 创建报文的日期

    - Transfer-Encoding: 报文主体的传输编码格式

    - Trailer: 服文末端的首部一览

    - via：代理服务器的相关信息

  - 通用缓存首部字段

    - Cache-Control: 控制缓存
    - Pragma: HTTP/1.1以前的遗留字段Pragma:no-cache与Cache-Control:no-cache功能一致，只用在客户端发送请求时

- 请求首部

  - Accept
    - Accept: 客户端或者代理能处理的媒体类型
    - Accept-Encoding: 优先可处理的编码格式
    - Accept-Language:优先可处理的自然语言
    - Accept-Charset:优先可处理的字符集
    - TE：传输编码的优先级
  - 条件请求首部字段
    - If-Match/If-None-Match
    - if-Modified-Since/if-Unmodified-Since
    - if-Range: 如果字段的值ETAG或时间与资源的ETAG或时间一致时，结合Range头进行范围请求，否则返回全体资源。
    - Range：范围请求，只获取部分资源，返回206
    - Expect：期待服务器的特定行为
  - 请求信息性首部字段
    - Host：请求资源所在的服务器
    - From：用户的邮箱地址
    - User-Agent：客户端程序信息
    - Referer:请求原始方的url
  - 安全请求首部字段
    - Authorization:web的认证信息
    - Cookie：HTTP/1.1中没有定义，用于客户端识别和跟踪状态的首部
  - 代理请求首部字段
    - Max-Forwards:最大的逐跳次数，只能和TRACE方法一起使用，每经过一层代理，值减1，如果应用程序收到请求时，首部值为0，则立即返回一条200的响应
    - Proxy-Authorization:代理服务器要求web认证信息

- 响应首部

  - 响应信息性首部字段
    - Age:响应已经产生了多长时间，HTTP/1.1规定缓存服务器在创建响应时必须包含Age首部
    - Location：客户端应重定向到指定URI，主要配合3XX响应出现
    - Retry-After：告诉客户端多久之后再次发送请求，主要配合503使用
    - Server：HTTP服务器的应用程序信息
  - 协商首部字段
    - Accept-Ranges:服务器是否能处理范围请求
    - Vary:
      - 通知客户端，服务端的协商中会使用哪些来自客户端请求的首部
      - 缓存控制，对某次请求，响应报文的Vary中会指定一些首部名称，客户端后续请求相同资源时，这些首部与缓存的那次请求完全一致时才会返回缓存资源
  - 安全响应首部字段
    - WWW-Authenticate/Proxy-Authenticate:服务器/代理服务器要求客户端的验证信息
    - Set-Cookie：非HTTP/1.1标准首部，服务端向客户端设置Cookie

- 实体首部

  - 实体信息性首部字段
    - Allow：通知客户端可以对指定资源使用哪些HTTP方法
  - 内容首部字段：
    - Content-Encoding
    - Content-Language
    - Content-Length
    - Content-Location:报文主体部分相对应的URI
    - Content-MD5：
    - Content-Range
    - Content-Type
  - 实体缓存首部字段
    - ETag
    - Expires
    - Last-Modified

### HTTP的keep-alive是干什么的

在早期HTTP/1.0版本，每一次HTTP请求都要建立一个连接，创建连接需要消耗资源和时间，为了减少资源消耗缩短时间，就需要重用连接。在HTTP请求头中加入Connection: keep-alive就可以告诉对方这个请求响应完成后不要关闭连接，下次还用这个请求继续交流。
优点：

1. 由于打开的连接少了，CPU和内存的使用会减少

2. 允许请求和应答的HTTP管线化
3. 降低拥塞控制
4. 减少后续请求的延迟
5. 报告错误无需关闭TCP连接

### HTTP状态码

- 1xx：信息状态码
  - 101 协议变更
- 2xx：成功状态码
  - 200 OK，表示请求成功
  - 201 Created， 请求已被实现，而且有一个新的资源已经依据请求需求而建立
  - 202 Accepted，请求被接受，但还没执行，不保证完成请求
  - 204 No content，请求成功，但响应报文不含任何主体部分
  - 206 Partial Content， 进行范围请求
- 3xx：重定向
  - 301 moved permanently，永久性重定义
  - 302 found, 临时性重定义
  - 303 see other，表示资源存在另一个URL，应使用get方法定向获取资源
  - 304 not modified， 一般是命中协商缓存时使用
- 4xx：客户端错误
  - 400 bad request，请求报文语法错误
  - 401 unauthorized，需要认证信息
  - 403 forbidden，资源禁止访问
  - 404 not found，资源不存在
- 5xx：服务端错误
  - 500 internal server error，服务端内部错误
  - 502 bad gateway，网关或代理服务器从上游服务器获取的响应无效
  - 503 service unavailable， 服务器处理超负载或正在维护

### 说说HTTPS

- HTTP协议数据都是明文进行传输的，缺乏安全性，而HTTPS就是为了解决HTTP的不安全的问题。
- HTTPS如何保证安全？
  - 先说一下对称加密和非对称加密。
  - 对称加密是使用同一个密钥进行加解密。在通信过程中，先把密钥发送给对方，把加密后内容发给对方，然后对方使用密钥解密。
  - 非对称加密则是有一个密钥对，公钥和私钥，公钥加密私钥解密，或者私钥加密公钥解密。在通信过程中，把自己的公钥发送给对方，对方使用公钥加密后把加密内容返回，然后用自己的私钥解密。
  - HTTPS则是结合这两种加密方式，将对称加密的密钥使用非对称加密的公钥加密，然后发送出去，接收方使用私钥解密，得到对称加密的密钥，然后双方可以使用对称加密进行沟通。
  - 但这样仍存在问题，即中间人可以在一开始发送公钥的时候，把公钥换成自己的公钥，这样就可以用自己的私钥来解密。
  - 这时就需要一个安全的第三方颁发的证书，证明发送方的身份，防止被中间人攻击。
  - 服务器会把带有自己公钥的这个第三方颁发的证书发送给客户端，客户端可以通过证书上的信息对发送方的身份进行验证，如果验证通过，说明这个公钥是可靠安全的。
  - 具体验证方式：证书颁发机构会先用证书指定的HASH算法对证书内容进行HASH得到摘要，再用机构自己的私钥加密，组成数字签名，然后得到签署了数字签名和服务器公钥的证书，服务器将这个证书发给客户端，客户端使用机构的公钥对数字签名进行解密得到摘要，然后使用证书上的HASH算法对内容进行HASH也得到摘要，对比两个摘要就知道中间是否被篡改。

### 说说HTTP2

相对于HTTP1有以下优势 ：

1. 二进制传输：之前的HTTP1.0是通过**文本的方式**传输数据，2.0采用**二进制格式**编码进行传输，速度更快。
2. 多路复用：一个TCP连接中可以**存在多个请求**，对端可以通过**帧中的标识**知道属于哪个请求，解决了**队头阻塞**的问题，提高传输效率。
3. 头部压缩：2.0对传输的header进行了**压缩**，并在两端维护了**索引表**，记录出现过的header，后面如果header的键值没变，就可以只传输键名。
4. 服务端推送：服务端可以在客户端的某个请求后，主动推送其它资源。

### 说说HTTP缓存

良好的缓存策略可以**降低资源的重复加载**，**提高网页的整体加载速度**。

缓存策略可分为强缓存和协商缓存：

- **强缓存**，可以通过两个响应头来实现
  - Expires，它是HTTP/1.0的规范，值是一个GMT格式的时间字符串，表示资源的有效期，当再次请求该资源时，会去判断当前时间是否超过有效期，如果没有超过就会命中强缓存，返回状态码200，使用缓存资源，如果超过了说明缓存可能已经过期了，将使用协商缓存。
  - Cache-Control: 它是HTTP/1.1的规范，优先级高于Expires，它可设置max-age的值，这个值的单位是秒，表示在N秒内再次请求资源会使用强缓存，否则会使用协商缓存。
- **协商缓存**，会去请求服务器验证当前缓存是否新鲜，它也有两种实现方式
  - Last-Modified（值为资源最后更新时间，随服务器response返回）
  - If-Modified-Since（通过比较两个时间来判断资源在两次请求期间是否有过修改，如果没有修改，则命中协商缓存）
  - ETag（表示资源内容的唯一标识，随服务器response返回）
  - If-None-Match（服务器通过比较请求头部的If-None-Match与当前资源的ETag是否一致来判断资源是否在两次请求之间有过修改，如果没有修改，则命中协商缓存）

### 说说TCP和UDP

> TCP是面向连接的，1对1通信，传输可靠，有序，可进行拥塞控制，但传输速度相对慢，量级较低，头部占20-60个字节

> UDP是无连接的，能提供单播，多播，广播的功能，传输不可靠，无序，不能进行拥塞控制，易丢包，但传输速度快，量级较高，头部大小仅占8字节。

- UDP，是一个面向报文的协议，UDP只是报文的搬运工，不会对报文进行任何拆分和拼接操作。
  - 传输过程：
    - 在发送端，应用层将数据传递给传输层的UDP 协议，UDP只会给数据增加一个UDP头标识一下是UDP协议，然后就传递给网络层
    - 在接收端，网络层将数据传递给传输层，UDP只去除IP报文头就传递给应用层，不会进行任何拼接操。
  - 特点：
    - UDP是无连接的，通信不需要建立和断开连接
    - UDP是不可靠的，协议收到什么数据就传递什么数据，不会备份数据，也不关心对方能不能收到
    - UDP没有拥塞控制，一直会以恒定的速度发送数据，即使网络条件不好，也不会对发送速率进行调整，这种情况下可能会导致丢包，但优点也很明显，在某些实时性要求高的场景，比如电话会议就需要使用UDP而不是TCP
  - 传输方式：UDP不止支持一对一的传输，同样支持一对多，多对多，多对一的方式，提供单播，多播、广播的功能。
- TCP是传输层另一个重要的协议：
  - 提供一种面向连接、可靠的字节流服务
  - 在一个TCP，仅有两方进行通信
  - TCP使用校验和、确认和重传机制来保证传输的可靠性
  - TCP给数据分节进行排序，并使用**累积确认**来保证数据的顺序不变和非重复
  - TCP使用滑动窗口机制来实现流量控制，通过动态改变窗口大小进行拥塞控制

### 说说TCP的三次握手和四次挥手

- 三次握手
  - 第一次握手，客户端向服务端发送一个SYN=1，SEQ=X的包，客户端进入SYN_SENT状态
  - 第二次握手，服务端向客户端发回一个SYN=1，ACK=1，SEQ=Y，ack_num为X+1的包，服务端进入SYN_REVD状态
  - 第三次握手，客户端再次向服务端发送一个ACK=1，ack_num=Y+1的包，双方进入established状态
- 四次挥手
  - 第一次挥手：假设客户端想关闭连接，客户端发送一个**FIN**=1，**SEQ**=X的包，表示自己没有数据可以发送，但可以接受数据，客户端进入**FIN_WAIT_1**状态
  - 第二次挥手：服务端接收后，发送一个**ACK=1**，ack_num=X+1的确认包，表示自己接受了客户端的关闭连接请求，但还没有准备好关闭连接，服务端进行CLOSE_WAIT状态，客户端接收到确认包后，进行FIN_WAIT_2状态，等待服务器关闭连接
  - 第三次挥手：服务端准备好关闭连接时，向客户端发送一个FIN=1，SEQ=Y的包，服务器进入LAST_ACK状态，等待客户端的最后一次确认
  - 第四次挥手：客户端接收到服务端的关闭请求，会向服务器发送一个ACK=1，ack_num=Y+1的确认包，并进入TIME_WAIT状态，等待可能出现的要求重传的ACK包，服务器端接收到这个包后，会关闭连接，进行CLOSED状态，客户端会等待两个最大段生命周期的时间，没有收到ACK包，就认为服务器正常关闭连接，于是自己也关闭连接，进入CLOSED状态。

### WEBSOCKET握手过程

Websocket是一个全新、独立的协议，基于TCP协议，与http协议兼容，作为H5的一部分，作用就是在服务端和客户端之间建立实时的双向通信。

优点：实时双向通信，性能好，延迟低

缺点：独立于http协议，需要额外的项目改造，使用复杂度高，无法兼容低版本浏览器

协议包括：

- 握手
  - 发送握手请求，是一个HTTP GET请求，协议版本至少是1.1，请求头比普通请求多了一些字段
    - Connection：值为Upgrade，告诉服务器当前请求连接是升级的
    - Upgrade：值为websocket，告诉服务器这个HTTP连接是升级的WS连接
    - Sec-Websocket-Version：值必须是13
    - Sec-Websocket-Key：发送一个key给服务端，服务端返回一个校验过的字符串给客户端，验证通过后才正式建立连接
    - Sec-Websocket-Protocol：表示客户端可以接受的子协议类，服务端要返回其中一个子协议。
  - 返回握手应答，响应行中的状态码为101，表示发生了协议变换，响应头中包含
    - Upgrade和Connection，告诉客户端同意升级并使用websocket协议
    - Sec-WebSocket-Accept，服务端将加密处理后的握手Key通过这个字段返回，表示服务器同意建立连接
    - Sec-WebSocket-Procotol，服务器选择一个应用层协议
- 数据传输
  - new Websocket(url) 握手
  - ws.onopen 指定连接成功的回调
  - ws.onerror 指定连接失败的回调
  - ws.onclose 指定连接关闭的回调
  - ws.send 发送信息
  - ws.onmessage 接收服务端消息

### 前端安全问题

- XSS：Cross-site Scripting，跨站脚本攻击，攻击者通过在目标网站注入恶意的js脚本，使之在用户的浏览器上运行
  - 根据攻击来源对XSS分类
    - 存储型XSS：将恶意代码保存到目标网站数据库，从数据库中获取恶意代码后，拼接到HTML，返回客户端然后被浏览器解析执行
    - 反射型XSS：用恶意代码构造出特殊的URL，用户打开URL后，恶意代码被取出并拼接到HTML，返回客户端，然后被浏览器执行
    - DOM型XSS：前端从URL中取出恶意代码然后插入到DOM中执行
  - 如何防御：
    - 转义输入输出的内容，对引号，尖括号，斜杠进行转义
    - 设置转义白名单
- CSRF：Cross-site Request Forgery，跨站请求伪造，攻击者利用用户的登录身份伪造恶意请求实现敏感操作。
  - 如何防御：
    - GET请求不对数据进行修改
    - 不让第三方网站访问到用户的本站中的Cookie
      - cookie响应头中设置SameSite属性
      - 存在兼容问题
    - 阻止第三方网站请求接口
      - 判断Referer请求头是不是来自第三方
    - 请求时附带验证信息，比如验证码或者token
      - 登录后返回随机Token
      - 请求时带上这个token
      - 因为第三方获取不到这个Token，从而不能完成请求

## 前端工程化和优化

### webpack的构建流程

1. 初始化参数：从配置文件和命令行中读取与合并参数，得到最终的参数
2. 开始编译：用参数初始化Compiler对象，加载所有配置的Plugin，执行对象的run方法开始执行编译
3. 确定入口：根据配置中的entry找出所有的入口文件
4. 编译模块：从入口文件出发，调用所有配置的Loader对模块进行翻译，再找出该模块的依赖，递归本步骤直到所有入口依赖的文件都经过Loader翻译
5. 完成模块编译：得到被翻译后的最终内容和它们的依赖关系
6. 输出资源：根据入口和模块间的依赖关系，组装成一个个包含多个模块的Chunk，再把每个Chunk转换成一个单独的文件加入输出列表，这一步是可以修改输出内容的最后机会
7. 完成输出：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写到文件系统。

### webpack和gulp的区别

- Gulp是基于任务的工具，自动执行指定的任务，如同流水线，把资源放上去然后通过不同插件进行加工，然后输出加工后的资源。
- Webpack是基于模块化的打包工具，自动化处理模块，把一切当成模块，当webpack处理应用程序时，它会递归地构建一个依赖关系图，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个bundle。

### bundle，chunk和module是什么

- bundle：是webpack打包出来的文件
- chunk: 是代码块，一个chunk由多个模块组合而成，用于代码的合并和分割
- module:是开发中的单个模块，在webpack中一切皆模块，一个模块对应一个文件，webpack会从配置的entry入口开始递归找出所有依赖的模块

### loader和plugin的区别

- 不同的作用：
  - Loader为加载器，webpack原生只能解析JS文件，如果想将其它文件也打包的话，就会用到loader，它的作用就是让webpack拥有加载解析非JS文件的能力。
  - Plugin为插件，可以扩展webpack的功能，在webpack运行的生命周期中会发布出很多事件，Plugin可以通过监听这些事，调用webpack的api改变输出的结果。
- 不同的用法：
  - Loader在modules.rules中配置，也就是说，它作模块的解析规则而存在。类型为数组，每一项都是一个对象，里面描述了对于什么类型的文件，用什么加载器和参数进行解析加载。
  - Plugin在plugins中单独配置。类型为数组，每一项是一个plugin实例，参数通过构造函数传入。

### 常用的loader

- file-loader：把文件输出到一个文件夹中，在代码中通过相对URL去引用输出的文件
- url-loader：和file-loader类似，能在文件很小的情况下以base64的方式把文件内容注入到代码中
- vue-loader: 能够让webpack解析Vue的单文件组件
- source-map-loader：加载额外的Source Map文件，以方便断点调试
- image-loader：加载并压缩图片文件
- babel-loader:把ES6转换成ES5
- css-loader:加载CSS，支持模块化、压缩、文件导入特性
- style-loader:把CSS代码注入到js中，通过DOM操作去加载CSS

### 常用的plugin

- define-plugin:定义环境变量
- html-webpack-plugin:简化HTML文件创建
- uglifyjs-webpack-plugin:通过uglifyjs压缩代码
- mini-css-extract-plugin:将CSS提取到单独的文件中，支持按需加载

### 如何编写loader和plugin

- Loader
  - Loader就像一个翻译官，把读到的源文件内容转义成新的文件内容，并且每个Loader通过链式操作，将源文件一步步翻译成想要的样子。
  - 编写Loader要遵循单一原则，每个Loader只做一种“翻译”工作。
  - 输入给Loader的是源文件内容source，通过返回值的方式将处理后的内容输出，也可以调用this.callback()方法，将内容返回给webpack。还可以通过this.aysnc()生成一个callback函数，再用这个callback将处理后的内容输出。此外webpack为开发者提供了开发loader的工具函数集——loader-utils。
- Plugin
  - webpack在运行的生命周期会发布很多事件，Plugin通过监听这些事件，调用webpack的api改变输出结果。

### 如何用webpack来优化前端性能

- 代码压缩：删除多余代码、注释、简化代码写法。如UglifyJsPlugin压缩JS文件，利用css-loader的minimize来压缩css
- 利用CDN加速
- Tree-shaking：剔除永远不会走到的代码片断
- Code Spliting:将代码按路由维度或组件分块，按需加载，同时可以充分利用浏览器缓存
- 提取公共第三方库：SplitChunksPlugin插件可以对公共模块抽取，利用浏览器缓存可以长期缓存这些无需频繁变动的公共代码。

### 如何提高webpack的打包速度

- 提取公共文件：多入口情况下，使用CommonChunkPlugin
- 外部扩展：通过externals配置来提取常用库，将不怎么需要更新的第三方库脱离webpack打包，不被打入bundle中，从而减少打包时间，如jQuery用script标签引入
- dll：利用DllPlugin和DllReferencePlugin预编译资源模块，让一些基本不会改动的代码先打包成静态资源，避免反复编译
- 利用缓存：webpack.cache、babel-loader.cacheDirectory、HappyPack.cache都可以利用缓存提高rebuild效率
- 缩小文件搜索范围：比如babel-loader插件，如果你的文件仅存在于src中，那么可以设置include:path.resolve(__dirname,'src')

- happypack多线程编译：利用进程并行编译loader，利用缓存来使得rebuild更快，类似的替代者是thread-loader
- 提升代码压缩速度：webpack-uglify-parallel,多核并行压缩
- 使用Tree-shaking和Scope Hoisting剔除多余代码。

### 怎么配置单页应用和多页应用

- 单页应用：直接在entry中指定单页应用的入口即可
- 多页应用：可以使用webpack的AutoWebPlugin插件来完成简单自动化的构建，但是前提是项目的目录结构必须遵守它预设的规范
  - 每个页面都有公共的代码，可以将这些代码抽离出来，避免重复加载
  - 随着业务不断扩展，页面可能会不断追加，所以一定要让入口的配置足够灵活，避免每次添加新页面还需要修改构建配置

### babel的原理

1. 解析：将代码解析生成抽象语法树（AST），即词法分析和语法分析的过程
2. 转换：babel接受AST并通过babel-traverse对其进行遍历，在此过程中进行添加、更新及移除等操作
3. 生成：使用babel-generator模块将变换后的AST再转换为JS代码，

### git工作流是怎样的

GitFlow是一个git操作流程标准，包含如下如个关键分支：

| 名称    | 说明                                                         |
| ------- | ------------------------------------------------------------ |
| master  | 主分支                                                       |
| develop | 主开发分支，包含确定即将发布的代码                           |
| feature | 新功能分支，一般一个新功能对应一个分支，对于功能的拆分需要比较合理，以避免一些后面不必要的代码冲突 |
| release | 发布分支，发布时候用的分支，一般测试时候发现的 bug 在这个分支进行修复 |
| hotfix  | hotfix 分支，紧急修 bug 的时候用                             |

feature分支都是从develop分支创建的，完成后再合并到develop分支，等待发布

当需要发布时，我们从develop分支创建一个release分支

然后这个release分支会发布到测试环境进行测试，如果发现问题就在这个分支直接进行修复

在所有问题修复之前，我们会不停地重复发布->测试->修复->重新发布->重新测试这个流程

发布结束后，这个release分支会合并到develop和master分支，从而保证不会有代码丢失

master分支只跟踪已经发布的代码，合并到master上的commit只能来自release分支和hotfix分支

hotfix分支的作用是紧急修复一些Bug，它们都是从master分支上的某个tag建立，修复结束后再合并到develop和master分支上

### rebase与merge的区别

二者都是用于从一个分支获取并且合并到当前分支。

merge会自动创建一个新的commit

rebase会合并之前的commit历史

### git reset\git revert\git checkout的区别

git仓库包括三个组成部分：

- 工作区（Working Directory)，在git管理下的正常目录都算是工作区，我们平时编辑工作都是在工作区完成

- 暂存区（Stage)，临时区域，里面存放要提交文件的快照，执行git add .将文件放入暂存区
- 历史记录区（History），历史记录区，git commit 后文件存入历史记录区

- git reset只是把文件从暂存区拿到工作区，不影响历史记录区的内容，而且不支持--mixed --soft和--hard
- git checkout则是把文件从历史记录区拿到工作区，不影响暂存区的内容
- git revert不支持文件层面的操作

### 首屏优化

- 使用loading提示
- 使用骨架屏
- 服务端渲染
- 开启HTTP2
- 开启浏览器缓存
- 图片懒加载
- cdn
- keep-alive
- 动态加载路由页面

### 怎么做前端优化？

1. 网页内容
   - 减少HTTP请求次数
   - 减少DNS查询次数
   - 避免页面跳转
   - AJAX缓存
   - 懒加载
   - 提前加载
   - 减少DOM元素数量
   - 根据域名划分内容
   - 减少iframe数量
2. 服务器
   - 使用CDN
   - 添加Expires或者Cache Control报文头
   - Gzip压缩文件
   - 配置Etags
   - 尽早flush输出
   - 使用ajax
   - 避免空的图片src
3. Cookie
   - 减少Cookie大小
   - 页面内容使用无Cookie域名
4. CSS
   - 样式表置顶
   - 避免CSS表达式
   - 代替@import
   - 避免使用Filters
5. JS
   - 脚本置底
   - 使用外部js和CSS文件
   - 精简JS和CSS
   - 去除重复脚本
   - 减少DOM操作
   - 使用事件代理
6. 图片
   - 优化图片
   - 使用雪碧图
   - 不要在HTML中缩放图片
   - 使用小且可缓存的ico