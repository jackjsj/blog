---
sidebar: auto
---

# 前端面试题

## HTML

### SEO（搜索引擎优化，Search Engine Optimization）

前端需注意的SEO有：

- 合理使用`title`、`description`、`keywords`：这三项的**权重**逐个减小；
- **语义化**的`HTML`代码：让搜索引擎更容易理解网页；
- 重要的`HTML`代码要放在最前：搜索引擎抓取`HTML`顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容优先被抓取；
- 重要内容不要用`js`输出并且少用`iframe`：爬虫不会执行`js`，也不会抓取`iframe`中的内容；
- **非装饰性图片**必须加`alt`属性；
- 提高网站**速度**：网站速度是搜索引擎排序的一个重要指标

>记忆技巧：
>
>搜索引擎优化
>	搜
>		搜索3要素
>			title
>			description
>			keyword
>	索
>		说话
>			语义化
>				使用语义化标签，让搜索引擎更容易理解网页
>	引
>		引用
>			引用内容要从上到下
>				重要的HTML内容要放在前面
>					搜索引擎抓取HTML顺序是从上到下的
>					有的搜索引擎对抓取长度有限制
>					保证重要内容优先被抓取
>	擎
>		js引擎
>			重要内容不要用js输出
>				少用frame
>					搜索引擎不会执行js
>					不会抓取frame中的内容
>	优
>		速度优化
>			加载速度优化
>				在搜索引擎排序的一个重要指标
>	化
>		画
>			画图
>				图片
>					非装饰性图片必须加alt属性

### doctype的作用

- DOCTYPE是HTML的**标准声明**，必须声明在HTML文档**第一行**。它的作用是**告知**浏览器解析器用什么文档标准来解析页面。
- 有两种解析模式：标准模式和怪异模式。
  - 标准模式是使用**W3C**的标准解析渲染页面。
  - 怪异模式是用浏览器**自己的标准**解析渲染页面，不同浏览器看到的渲染结果不同，**不声明DOCTYPE就会使用怪异模式**。

### HTML、XML和XHTML的区别

- HTML是**超文本标记语言**，在HTML4.0**前先有实现后有标准**，导致HTML非常混乱和松散
- XML是可**扩展标记语言**，主要用来**存储数据**，可以扩展。
- XHTML是**可扩展超文本标记语言**，基于HTML和XML，W3C用它来解决HTML的混乱问题，并基于此诞生了**HTML5**，在开头加了DOCTYPE声明，开启标准模式。

### HTML5新特性

1. H5文档声明类型**仅有一型**，即`<!DOCTYPE HTML>`，**不再基于SGML**，不需要引用**DTD**
2. **新元素标签**，如**语义化标签**header, footer, section, nav, aside，**多媒体标签**video, audio, canvas
3. **input元素**添加了**新的类型**，如date, time, email等。
4. 添加了**新的技术**，如`WebWorker`、`Websocket`、`Geolocation`
5. **新增属性**和指定了**全域属性**, 比如meta标签的charset属性, script标签的defer和async属性，全域属性包括id, tabindex, repeat。
6. H5**移除**了一些元素，如big, center, font, frame等等

### 什么是HTML语义化

HTML语义化就是**使用适当语义**的HTML标签，让页面具有**良好的结构和含义**。

它的好处主要有两点：

1. 对开发者友好，**增强代码可读性**，**便于团队开发和维护**
2. 对机器友好，适合搜索引擎的**爬取有效信息**，**支持读屏软件**，**根据文档生成目录**等。

### 常用meta标签有哪些

meta标签用来**描述HTML文档元信息**，

可以定义`keyword`和**`description`**，用于SEO搜索引擎优化。

比如`charset`，设置**文档字符编码**

`http-equiv`, 可以如设置**http缓存过期时间**，设置刷新间隔时间

`viewport`，常用于**移动端开发**，可以**控制视口的大小和比例**，**用户是否可缩放视口**等。

```html
<meta name="viewport" content="width=device-width，initial-scale=1，minimum-scale=1, maximum-scale=1，user-scalable=no">
<!-- 不缓存当前页面的设置 -->
<meta http-equiv=”pragma” content=”no-cache”>
<meta http-equiv=”cache-control” content=”no-cache”>
<meta http-equiv=”expires” content=”0″>
```

### src和href的区别

- src
  - 指向**外部资源的位置**；
  - 会将指向的内容**下载并会嵌入**到标签所在位置；
  - 当浏览器解析到这个元素时，**会暂停其它资源下载和处理**，直到资源加载、编译、执行完毕。
- href
  - 指向**网络资源的位置**
  - 用来**建立**当前元素与文档间的**链接**
  - 当浏览器识别到它指向的文件时，会并行下载资源，**不会停止对当前文档的处理**。

### img标签的title和alt有什么区别

- `title`是当鼠标悬浮在元素上的时候显示
- `alt`是的特有属性，是图片内容的等价描述，当图片无法加载时显示、可用于读屏器阅读图片，提高图片的访问性，非装饰性图片都必须设置有意义的值，有利于SEO。

### Canvas和SVG的区别

- `svg`绘制出来的每一个图形的元素都是独立的`DOM`节点，而`canvas`输出的是一整幅画布。
- `svg`输出的图形是矢量图形，能修改参数自由放大缩小，不会失真。而`canvas`输出的画布就像一张图片，放大时会失真。

### script标签的defer和async的区别

- 默认遇到script标签会停止HTML解析，等待脚本**加载执行完毕**后，才继续解析文档。
- 加async属性，脚本会**异步加载**，加载完后立即执行，**阻塞HTML解析**，而且**不能保证脚本执行顺序**
- 加defer属性，脚本也会**异步加载**，但**不会立即执行**，会等到HTML解析完成后再执行，能**保证脚本执行顺序**。

### 前端存储方式

有3种存储方式，分别是cookie, localStorage/sessionStorage, indexedDB。

1. cookie的优点就是**兼容性好**，**使用方便**。缺点是大小**只有4KB**，请求头**自带cookie浪费流量**，**每个domain的cookie个数有限制**。
2. localStorage是**永久存储**，除非手动删除，可在所有同源窗口中共享
3. sessionStorage是**会话级存储**，即页面关闭数据就没了，不能在同源窗口中共享。
4. indexedDB是H5的**数据库储存**方案，允许存大容量数据，用**key-value**进行存储，用**JS操作方便**

## CSS

### CSS选择器优先级

- 内联>id>class 属性 伪类>tag 伪元素

### link和@import的区别

1. link是**标签**，可以用**DOM操作**，@import是**CSS提供**的，**不能用DOM**操作。
2. **link引入的资源**会在**页面加载时加载**，而@import引用的CSS会等到**页面加载完才加载**
3. link**无兼容问题**，@import只在**IE5以上**才能识别

### CSS隐藏元素的方式和区别

- display:none: 不占空间，不可交互
- visibility:hidden：占空间，不可交互
- opacity:0：占空间，可交互
- transform:scale(0,0)：占空间，不可交互

### CSS有几种定位方式

- 五种，分别是static\relative\absolute\fixed\sticky
- sticky是relative和fixed的结合体，在屏幕范围内同relative，要滚出屏幕时就和fixed一样

### 盒模型

标准盒模型和IE盒模型，**标准**盒模型的宽高**就是内容的宽度**，而**IE盒模型**的宽高是**内容+内边距+边框**后的结果。

### 伪元素和伪类

- 伪元素是在文档树以外创建了一个虚拟容器，通过给它**添加样式来实现一些效果**，如before,after
- 伪类表示元素的**某种特定状态**，如active, hover

### BFC

- BFC**块级格式化上下文**，是页面中一块**独立的渲染区域**，有一些**渲染规则和特性**，**决定了**它的**子元素**如何布局，它**内部**的元素与**外部**的元素**相互隔离，互不影响**。
- 符合一些**条件**就可以触发BFC：
  - **根**元素
  - **浮动**元素
  - position为**absolute或fixed**的元素
  - **overflow不为visible**的元素
  - display为`inline-block\table\table-cell\table-caption\flex\inline-flex\grid\inline-grid`的元素等
- BFC有一些**特性**，比如：
  - BFC内部盒子会在垂直方向**一个接一个**地排列
  - BFC内部盒子**垂直方向的距离**由外边距决定，同属一个BFC的相邻盒子**垂直外边距**会重叠
  - BFC内部盒子的margin左边与包含块border左边**相接触**，即使存在浮动也是如此
  - BFC区域不会与**其它浮动盒子**发生重叠
  - BFC**计算高度**的时候，浮动盒子也参与计算

- 根据这些特征，我们常用BFC来
  - 实现**双栏**自适应布局
  - **清除浮动**
  - 解决**外边距塌陷**问题

> 记忆技巧
>
> 特性
> 	1
> 		一个接一个
> 			BFC内部盒子在垂直方向一个接一个的排列
> 	2
> 		垂直
> 			BFC内部盒子垂直方向的距离由外边距决定
> 			垂直方向外边距会重叠
> 	3
> 		三
> 			三根线都不接触
> 				接触
> 					BFC内部盒子的margin左边和包含盒子的border左边相接触，即使存在浮动也是如此
> 	4
> 		私服
> 			浮动
> 				BFC不与其它浮动盒子相重叠
> 	5
> 		呜呜呜
> 			哭泣的声音很高
> 				BFC计算高度时，浮动盒子也参与计算

### 媒体查询

- 媒体查询是网页对**不同型号设备**做出**适配**的**响应式设计方案**。
- 媒体查询包括
  - 可选的媒体类型
  - 若干表达式，这些表达式描述了媒体特征，如果满足这些特征，媒体查询内的样式就会被使用。

### z-index和层叠上下文

- **层叠上下文**是一个**三维概念**，如果一个元素是层叠上下文元素，那么这个元素在Z轴上就“高人一等”。
- **层叠水平**，决定了同一层叠上下文中元素在Z轴的显示顺序，普通元素的层叠水平优先由层叠上下文决定，层叠水平的比较只有在当前层叠上下文元素中才有意义
- **层叠顺序**，表示元素在发生叠时候有着特定的垂直显示顺序。
  - 层叠上下文的border和background
  - 负的z-index元素

  - block块级元素

  - float元素

  - inline/inline-block元素

  - z-index为auto或为0的元素

  - 正的z-index元素
- 元素符合一些条件可以**创建**层叠上下文：

  - html**根**元素
  - **z-index不是auto的定位**元素
  - **flex项目**元素
  - 设置了一些css3属性的元素
    - **opacity**小于1
    - **transform/filter/perspective**不为none的元素
- 它有一些**特性**：

  - 每个层叠上下文**自成一体**，**整个元素**在**父层叠上下文中的顺序**中。
  - 每个层叠上下文**和兄弟元素**相互独立
  - 层叠上下文**可以嵌套**，**内部**层叠上下文**和它的子元素**都**受制于**外部的层叠上下文

> 记忆技巧
>
> 特性
> 	1
> 		自成一体
> 			在父叠层上下文中的顺序中
> 	2
> 		两兄弟
> 			和兄弟之前相互独立
> 	3
> 		3同山
> 			嵌套
> 				层叠上下文可以嵌套，内部层叠上下文和它的子元素受制于外部的层叠上下文

## Javascript

### 原型和原型链

1. 几乎所有**函数**都有一个prototype属性，它会指向这个函数创建的**实例对象**的原型
2. **实例对象**也会有一个`__proto__`属性指向自己的隐式原型。(`Person.prototype === person.__proto__`)
3. 原型是个对象，它有一个 `constructor` 属性指向构造函数本身
4. 原型有以下特点：
   - 原型对象上添加属性，所有实例都会共享这些属性
   - 在对象上查找自身没有的属性时，会从对象的原型上找，找不到就找原型的原型，一直找到 Object.prototype，找不到就返回undefined
5. 原型链就是查找对象属性时所形成的链式结构。

### 作用域和作用域链

1. 代码**定义变量**的区域，它规定了**如何查找**变量，确定当前执行代码对变量的**访问权限**。
2. 根据代码所在的位置可分为：全局、函数和 eval 作用域。
3. JS 是**静态作用域**，函数的作用域在函数创建的时候就已确定。
4. 作用域可**嵌套**，在查找变量时，先从当前作用域中查找，找不到就在外层的作用域中找，一直找到全局作用域，找不到就报错。
5. **逐层嵌套**的作用域形成的链式结构就是作用域链。

### 闭包

1.  函数嵌套，内部函数引用了外部函数的变量，这样就能产生闭包；
2.  闭包有两种理解：
    - 这个内部函数就是闭包
    - 闭包是包含引用变量的对象，谷歌浏览器debugger时可以看到这个closure对象。
3.  闭包的作用
    - **延长**了引用变量的**生命周期**
    - 让**外部可以**使用函数**内部**的变量，**突破了作用域**的限制
4.  闭包的缺点
    - **变量未释放**会**占用内存**
    - **滥用**闭包会导致**内存泄漏**

### this 的指向

1. 默认情况，非严格模式，this 指向全局对象
2. 在函数中 this 一般指向调用该函数的对象
3. 使用 call,apply,bind 方法可显式指定 this 的指向
4. 使用 new 调用构造函数，函数中的 this 指向新创建的实例对象
5. 箭头函数没有自己的 this，函数中的 this 指向箭头函数所在的上下文中的 this

### js 执行过程

一段JS代码的运行可分为两个阶段：

- **编译**阶段，先进行分词/**词法分析**，再进行解析/**语法分析**，最后进行**预编译**
- 执行阶段，js代码**并非简单的一行行**解释执行的，而是将js代码分为**一块块**的**可执行代码块**进行执行，可分为三类，分别是
  - **全局**代码块
  - **函数**代码块
  - **eval**代码块

JS引擎由两个主要部分组成：

- 内存堆：是**内存分配地址**的地方
- 调用栈：是**代码执行**地方

在代码块**执行前会先创建执行上下文**，三种代码块会对应三种执行上下文，分别是全局、函数和eval执行上下文。

在js引擎首次读取代码时，会创建一个全局执行上下文并将其推入当前的执行栈。每当发生一个函数调用，引擎都会为该函数创建一个新的执行上下文并将其推到当前执行栈顶端。引擎会运行执行上下文栈顶端的函数，当此函数运行完成后，其对应的上下文将会从执行栈中弹出。最终执行栈中的上下文会被清空，这时所有代码执行完毕。

### null 与 undefined 的区别

- `undefined`表示变量**声明了，未赋值**。
- `null`表示**赋值了，值为空**，将变量赋值为null可用来**主动释放**对象的引用。

### == 和 === 的区别

- === 判断类型和值是否相同，对象类型比较的是内存地址值。
- 用==判断时，如类型相同，会去使用===判断，如类型不同会做隐式类型转换，具体判断流程如下：
  - 判断是否对比` null `和 `undefined`，是就返回 true
  - 判断是否对比 `string `和 `number`，是就将 string 转成 number 再比较
  - 判断其中一方是否为` boolean`，是就将 boolean 转成 number 再比较
  - 判断其中一方是否为 `object`，且另一方为 string，number，symbol，是就把 object 转成原始类型。

### 为什么会有bigint提案

- js所有数字都保存成**64位浮点数**，这给数值的表示带来**两大限制**。
  - 一是数值的**精度**只能到**53个二进制位**（相当于16个十进制位），**大于这个范围**的整数，**无法精确表示**，不适合**科学金融**方面的精确计算。
  - 二是大于或等于**2的1024次方**的数值，**无法表示**，会返回**Infinity**。
- bigInt就是用来解决这个问题的，只能表示**整数**，**没有位数限制**，**任何位数的整数都能精确表示**。为了与Number类型区别，bigInt必须添加后缀n。

### 为什么0.1+0.2!=0.3

- js中的数字是用64位二进制表示的
  - 其中**第1位是符号位**；
  - 2到12位，共11位是**指数部分**；
  - 第13到64位，共52位是**小数部分**，如果小数部分**超过52位，就会丢失精度**。
- 0.1用**二进制**表示时，小数部分是**1001无限循环**，13次1001就占了52位，第53位是1，0舍1入舍去，最后4位最终会变成1010，这样肯定就比0.1大了。0.2也类似，最终相加实际比0.3大。

### 变量提升和函数提升

- 变量提升：var声明的变量，在声明前就可以访问，此时变量值为undefined。
- 函数提升：用function声明函数，在声明前就可以直接调用。
- **函数提升>变量提升**，且被变量声明覆盖，但会被变量赋值之后覆盖。
- **形参赋值在前，变量提升在后**
- 在if判断里声明的var和function都只声明，不赋值，只要进到当前if条件中，会立即对fn进行赋值，这种现象发生成ES6以后
  - 因为ES6中if\for\while的{}被解析成块级作用域
- return下面的代码进行变量提升，提return后面的不进行变量提升
- let和const有**临时死区**的特性，必须声明才能使用，否则报错。

### 模块化

> 模块化的**好处**

- 避免命名冲突
- 更好的分离，按需加载
- 高复用性
- 便于维护

> 模块化标准

- CommonJS (NodeJS使用的规范)
  - module.exports 暴露接口
  - require 引入模块
  - 浏览器端需要借助Browserify将文件打包编译
- AMD
  - RequireJS
    - define方法，将代码定义为模块
    - require方法，实现代码的模块加载
- CMD 整合了CommonJS和AMD规范的特点
  - Sea.js
- ES6 编译时就确定模块的依赖关系
  - export 暴露接口
  - import 引入接口

> 总结

- CommonJS规范主要用于**服务端编程**，加载模块是**同步**的，**并不适合在浏览器环境**，因为同步意味着阻塞加载，浏览器资源是异步加载的，因此有了AMD CMD解决方案。
- AMD规范和CMD规范都可在浏览器环境中异步加载模块，而且可以并行加载多个模块，代表有requirejs
- **ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案**。

> ES6模块与CommonJS模块的区别

- CommonJS模块输出的是一个**值的拷贝**，加载模块后，在模块内**改变值不会影响到输出值**；
- ES6模块输出的是**值的引用**，模块内的**输出值变**了，**会影响到引用它的地方**。
- CommonJS模块是**运行时加载**，
- ES6模块是**编译时输出接口**。

### V8 垃圾回收机制

- V8将内存堆分为两个空间：**新生代**和**老生代**，**新**生代中的对象**存活时间较短**，**老**生代中的**对象存活时间较长**。
- 在新生代空间中，内存空间又分为**两部分**，f**rom空间和to空间**。一个空间是**使用的**，另一个空间是**空闲的**。**新分配的对象**会被放入From空间中，**当From空间占满时**，就会启动**Scavenge算法**进行垃圾回收。该算法会**检查**from空间中存活的对象，判断对象是否符合**晋升条件**，如果符合就**晋升成老生代**，否则将对象复制到To空间中，如果有失活的对象就会销毁。当复制完成后将from空间和to**空间互换**，这样垃圾回收就结束了。
- 老生代空间会使用两个算法，**标记清除算法**和**标记压缩算法**。
- **标记清除算法**就是**遍历**堆中所有对象，将存活对象**标记**出来，然后对**未标记的对象空间**进行**回收**。
- 但经过标记清除后，会造成堆内存**出现碎片**的情况，当**碎片超过一定限制**后就会启动**标记压缩算法**，将活的对象向一端移动，直到所有对象都移动到一边，然后**清理掉不需要的内存**。

### 事件循环

事件循环是协调**js单线程运行**时**不会阻塞**的**一种机制**。

首先在我们**JS**中，有一个**主线程**，主线程中有一个**调用栈**，在调用栈中执行我们的**同步代码**。

当我们的代码中有**setTimeout, setInterval 或 ajax 等异步操作**的时候，这些异步任务**不会在主线程中执行**，而是js引擎将他们交给对应的**定时器触发线程或HTTP请求线程**去执行，然后这些线程处理完毕后，会将回调函数**按顺序**放到一个**任务队列**当中。

当调用栈中的代码**全部执行完毕后**，js引擎才会**去任务队列中找**有没有异步任务，如果有就**依次将它们放入调用栈中**执行。

实际上，任务队列分成**宏任务队列**和**微任务队列**。

- 宏任务：script 代码，setTimeout/setInterval  （setImmediate, I/O）
- 微任务：Promise, MutationObserver （process.nextTick）

JS引擎**一开始**会在调用栈中执行一个宏任务，也就是**script代码**，执行过程中**可能会产生新的宏任务和微任务**，分别将他们放入对应的任务队列中，当调用栈中的代码被执行完以后，会查看微任务队列中是否有微任务，如果有就执行所有的微任务，这样就完成一轮事件循环，如还有宏任务，则执行新的宏任务，开启下一轮循环。

### JS异步编程方式

- 回调函数
- 事件监听
- 发布订阅
- Promise
  - Promise是**ES6新增**的语法，是**异步编程**的一种解决方案，解决了传统回调函数方式导致的**回调地狱**的问题。
  - Promise是一个**构造函数**，**接受一个方法作为参数**，方法有两个参数，分别是resolve和reject。
  - 通过构造函数可以创建Promise实例，Promise实例对象有**三种状态**，初始为pending状态，通过调用resolve或reject方法可将状态转变为resolved和rejected状态，状态一旦改变就不能再次改变。
  - promise实例对象还有一个**then方法**，它接受一个回调函数，当状态从pending变为resolved或rejected后，就会执行then中的这个回调，他的**返回值**是一个新的promise实例，因此可以进行**链式调用**。
- async/await
  - 是Generator函数的语法糖，Generator函数的执行需要执行器，async函数自带执行器
  - async 声明一个异步函数，其返回值是一个Promise对象，只有在async函数内部异步操作执行完，才会执行then方法指定的回调，内部可使用await
  - await只能在async声明的函数中使用，放在Promise对象前，后面的代码会等到Promise完成并返回结果后才执行。
  - 优势
    - 同步的写法更加优雅，不仅解决了回调地狱问题，还省去了then的链式调用所带来的阅读负担
    - 处理错误的方式更加友好，可以用try/catch方式，而不是Promise的错误捕获方式
    - 调试更加方便
- Generator
  - Generator是ES6中新增的语法，也是异步编程的解决方案。
  - 声明函数时在函数名前加*号，就可以声明一个Generator函数，函数内使用yield表达式，定义不同的内部状态，执行该函数会返回一个遍历器对象。
  - 这个遍历器对象代表Generator函数的内部指针，每次调用遍历器对象的next方法，会返回一个有value和done两个属性的对象。
  - value属性表示当前内部状态的值，是yield表达式后面那个表达式的值；done属性是一个boolean，表示是否遍历结束

### ES6的新特性

- 新增了let和const命令
- 模板字符串
- 函数参数默认值
- 箭头函数
  - this指向
- 新增了两个基本类型：Symbol和BigInt
  - BigInt要解决什么问题？
- 新增了数据类型：Set和Map, WeakSet和WeakMap
  - Set中的成员中没有重复的值
  - Map本质也是键值对的集合，但它的键可以是各种类型的值（包括对象），而对象的键只能是字符串或Symbol
  - WeakSet中只能是对象，并且是弱引用，也就是垃圾回收不考虑weakset对该对象的引用，只要对象在外部消失，weakset中的引用会自动消失
  - WeakMap的键名只能是对象，键名指向的对象也不计入垃圾回收机制。
- 对象和数组的解构赋值
- Promise
  - 事件循环
- async/await
  - 事件循环
  - generator 自动执行器
- 迭代器
  - for...of 可以break
- class
  - 创建对象的方式
  - 继承
- Proxy
  - vue3.0的数据劫持方式，替代Object.defineProperty
- Import/Export
  - 模块化 CommonJS/amd/cmd/es6模块化标准
  - import与CommonJS的require区别

## Vue相关

### 虚拟DOM

- **本质**是用一个**原生JS**对象去**模拟**一个DOM节点，是对**真实DOM**的一层**抽象**。

- 为什么要用虚拟DOM？
  - 直接频繁操作DOM不好，表现在
    - JS操作DOM相对比较慢，**JS引擎**和**渲染引擎**是相互独立的，双方通信需要成本。
    - 频繁操作DOM会造成浏览器**大量回流和重绘**，**消耗大量性能**。
    - 省略**手动操作DOM**可以**提高开发效率**
  - 初衷是为了**跨平台**，nodejs环境中没有DOM，如果想**实现服务端渲染**（SSR），需要**借助VDOM**。

### diff算法（snabbdom.js）

- 将**虚拟DOM树同一级**的**新节点数组**与**旧节点数组**进行对比，并用**四个指针**分别指向这**两个数组**的**头尾**。

- 一直循环进行**头尾交叉对比**，直到两个数组中**任一数组**的**头指针超过尾指针** ，具体过程是:
  - 头头对比: 如相同把新节点patch到旧节点，头指针后移，否则继续
  - 尾尾对比: 如相同把新节点patch到旧节点，尾指针前移，否则继续
  - 旧尾新头对比: 如相同，把新节点patch到旧节点，旧尾指针前移，新头指针后移，否则继续
  - 旧头新尾对比: 如相同，把新节点patch到旧节点，新尾指针前移，旧头指针后移，否则继续
  - 利用key对比: 在旧节点数组中寻找新头指针指向的节点的key，这里**分三种**情况，
    - 没有对应的key，那创建新节点
    - 如果有对应key并且是相同的节点，把新节点patch到旧节点
    - 如果有对应key但是不是相同的节点，那也创建新节点

- 循环结束后，两个数组中可能存在没有遍历完的情况
  - 如新数组没遍历完，则添加新数组中漏掉的节点
  - 如旧数组没遍历完，则删除旧数组中漏掉的节点

### MVVM是什么

- 概述
  - MVVM是`Model-View-ViewModel`的缩写，分为三层
  - Model层主要是提供**数据模型**；
  - View层则是的提供**视图模板**，定义**结构布局**，展示**数据状态**，做了数据和事件的**绑定声明**，**指令声明**；
  - ViewModel是**View**和**Model**层的**桥梁**，**数据绑定在ViewModel层**会**自动**将数据渲染到页面，**双向绑定**的**视图变化**的时候也会通知ViewModel层更新数据。
- 优点
  - **分离**视图和模型，**降低**代码耦合，**提高**视图和逻辑复用
  - **双向绑定DOM**自动更新，开发者不用手动操作DOM，**提高开发效率**
  - 便于**测试**
- 缺点
  - BUG难调试，**双向绑定导致**BUG**难以定位**错误发生在View层还是Model层。
  - **大型应用**维护**数据多**，**ViewModel**构建**维护成本**会增大，Model层的**数据长期持有**也会大量占用内存。

### Vue的生命周期

- beforeCreate：当前阶段data、methods、computed以及watch上的数据和方法**都不可访问**。
- created：发生在**实例创建后**，**完成数据监测**，可**使用和获取**数据，但**无法与DOM交互**。
- beforeMount：发生在**DOM挂载前**，这时候**虚拟DOM已创建完成**，**即将开始渲染**。
- mounted：发生在**DOM挂载后**，数据**完成双向绑定**，**可访问DOM**。
- beforeUpdate：发生在**响应式数据更新前**，这时候虚拟DOM还没有重新渲染，还**可以更改数据**。
- updated：发生在**数据更新后**，**不能在此更改数据**，可能会导致**死循环**。
- beforeDestroy：发生在**组件销毁前**，可进行**收尾工作**，比如清除定时器。
- destroyed：发生在**组件销毁后**，只剩下DOM空壳，**数据绑定**和**监听**都被移除，**子组件**也被销毁。

### Vue的通信方式

1. `props/$emit+v-on`，通过props将数据自上而下传递，通过$emit和v-on向上传递；
2. 通过中央事件总线`EventBus`进行信息的发布订阅，利用vue实例的$emit和$on
3. 使用`vuex`，全局状态管理
4. 使用`$attrs/$listeners`，配置v-bind="$attrs"获取在父中定义的所有属性，配置v-on="$listeners"获取子中发布的所有事件
5. 使用`ref`可在父中访问子实例
6. 使用`$children/$parent`访问实例
7. 使用`provide/inject`，父通过provide提供变量，子通过inject注入变量，不管多深，但数据是非响应式的。
8. `localStorage/sessionStorage`

### computed和watch的区别

- computed是依赖于一个或多个属性，然后改变指定的属性值，有缓存性，只有依赖的属性发生改变才重新计算，常用于格式化数据
- watch是监听一个属性的变化而做一系列操作，比如要调ajax请求。

### Vue如何实现双向绑定的

- 采用**数据劫持**结合**发布订阅**模式，通过**Object.defineProperty()**来**劫持**数据对象各属性的**setter、getter**，在**数据变动**时**发布消息**给订阅者，**触发**相应监听**回调**。
- 具体实现
  - 实现一个数据监听器`Observer`，能够对数据对象各属性进行**监听**，**如有变动获取最新值**，**通知订阅者**；
  - 实现一个指令解析器`Compile`，对每个**元素节点**的**指令**进行**扫描解析**，根据指令模板**替换数据**，以及**绑定**相应的**更新函数**；
  - 实现一个`Watcher`，作为连接`Observer`和`Compile`的桥梁，能够**订阅**并**收到属性变动通知**，**执行回调**，**更新视图**；
  - 最后实现一个`MVVM`入口，用来**接收数据对象**，**指定视图模板**。

### v-model的原理

- `v-model`本质是`value + input`方法的语法糖。可以通过vue组件中设定**model属性**并设置其`prop`和`event`属性来进行**自定义**。原生的v-model，会根据标签的不同生成**不同的属性和事件**。

### Vue事件绑定原理

- 原生事件绑定是通过`addEventListener`绑定给真实元素的，组件事件绑定是通过Vue自定义的`$on`实现的。

### Vue的模版编译原理

- Vue的编译过程就是将`template`转化为`render`函数的过程，主要分三步：
  1. 通过**解析器**，将**模板**转成**抽象语法树**（AST)；
  2. 通过**优化器**，对**AST**进行**静态节点标记**，主要用来做**虚拟DOM的渲染优化**；
  3. 通过**代码生成器**，将**AST**转成**render函数的代码字符串**。

### Proxy相对于Object.defineProperty的优势

1. 可以直接监听**对象而非属性**，不用再遍历对象的属性
2. 可以直接监听**数组**的变化
3. 有多达**13**种拦截方法
4. 返回一个**新对象**，可以**只操作新对象**达到**目的**
5. 作为**新标准**，受到浏览器厂商重点**持续性能优化**

> 记忆技巧
>
> 1
> 	1个对象
> 		可以直接监听对象而非属性，不需遍历
>
> 2
> 	2维数组
> 		可以监听数据的变动
>
> 3
> 	13
> 		多达13种拦截方式
>
> 4
> 	世界
> 		新世界
> 			新对象
> 				返回新对象，可以只操作新对象达到目的
>
> 5
> 	H5
> 		新标准
> 			浏览器厂商
> 			持续
> 			性能红利

### Vue中是如何检测数组变化

1. 使用了**数据劫持**的方式
2. 将数组操作的**7个方法**进行了**原型链重写**，指向了**自己定义**的数组方法，
3. 其实就是先调用了数组原本的方法，然后添加**通知依赖更新**的代码。
4. 这样当**调用数组api**时，就可以**检测**数组变化。
5. 如果数组中**包含**着**引用类型**，还会对数组中的引用类型**再次递归遍历**进行监控。

### Vue的key有什么用

- key是vue中**虚拟DOM的唯一标识**，通过这个key，**diff操作**可以**更准确，更快速**。
- 准确是因为，如果**不加key**，进行diff时，遇到同类型节点会选择**就地复用**，导致旧节点的**状态被保留**下来，产生一系列BUG
- 快速是因为，key是唯一的，查找一个节点**不需要遍历**，因此更快速。

### nextTick的作用和实现原理

- nextTick的作用是在**下次 DOM 更新结束之后再执行指定的回调**。在修改数据之后立即使用这个方法，可以获取更新后的 DOM。

- nextTick主要使用**微任务**实现，特殊情况会使用**宏任务**。根据**执行环境分别尝试采用**
  - `Promise.then`(微)
  - `MutationObserver`（微）
  - `setImmediate`（宏）
  - `如果以上都不行则采用setTimeout(fn,0)代替`（宏）

### keep-alive的作用

- `keep-alive`可以实现组件**缓存**，当**组件切换**时**不会**对当前组件进行**卸载**。
- 常用的两个属性`include/exclude`，允许设置只对哪些组件进行缓存。
- 两个生命周期钩子`activated/deactivated`，分别在组件**激活**和**休眠**时触发。

### Vuex的原理

- vuex是vue的**状态管理器**，它采用**集中式存储**的方式管理**应用中所有组件的状态**，可以使**数据流**变得**清晰**、**可追踪可预测**。
- vuex的**核心**是一个**store对象**，对象中包含了
  - **state和getter**，用来定义状态
  - **mutation和action**，用来改变状态，修改状态会自动触发视图更新
  - **module**，用于对状态进行**模块化分割**
  - 还提供了**mapState,mapGetters,mapActions,mapMutations**辅助函数**方便开发者**在实例中**处理store对象**
- Vuex利用了vue的**mixin机制**，混入**beforeCreate钩子**，在每个组件**实例化前**，**将store对象注入**，并**注册**了一个store的**引用属性$store**
- Vuex**内部维护**了一个vue实例，会将**state放入这个vue实例的data中**，把**getter放入computed计算属性中**，这样可以使它们都**具备响应式**的特性。
  - 组件访问$store.state上的属性实际访问的是这个内部vue实例data中的属性。
  - 访问$store.getter上的属性实际访问的是内部vue实例的computed中的属性。
  - 由于响应式，状态发生变化时，就会触发相应的监听回调，实现视图更新。

### Vue-Router的原理

Vue-Router主要提供了

- 两个全局组件:**router-view**和**router-link**
- 两个实例对象：**$router**和**$route**
- 两种路由模式：**hash**和**history**

在Vue中每个页面都是一个组件，一开始打开页面时，vue-router会根据当前的url路径，去路由表中找到匹配的路由，然后动态地将目标路由对应的组件渲染到router-view所在的区域。

点击router-link组件，vue-router会**通过改变hash**或者**调用H5提供的pushState和replaceState**的Api来改变地址栏上的URL，而**不会刷新页面**。

但当URL发生改变时，会**触发hashchange或popstate事件**，vue-router又会通过路由表找到当前URL路径匹配的路由，并将其对应的组件渲染到指定区域。

## 浏览器、HTTP和前端安全

### 从浏览器地址栏输入url到显示页面的步骤

<img src="https://camo.githubusercontent.com/030fd1b42089f456c1b8aecbb3d153693fc282e6/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f333137343730312d376133393962376633383665383938342e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430" alt="img" style="zoom:50%;" />

1. 浏览器先查看请求的资源**是否有缓存**，如果有并且**没有过期**，直接进行**文件转码解析**
2. 如果资源**没有缓存**，或者**缓存已过期**，则**解析**URL获取协议，域名，端口号和path，**组装**成一个HTTP GET**请求报文**
3. 然后进行DNS解析，将域名解析成IP地址，这个过程会先去找DNS缓存，查找顺序依次是
   1. **浏览器缓存**：浏览器会按照一定的频率缓存 DNS 记录。
   2. **操作系统**缓存：如果浏览器缓存中找不到需要的 DNS 记录，那就去操作系统中找。
   3. **路由**缓存：路由器也有 DNS 缓存。
   4. **ISP** 的 DNS 服务器：ISP 是互联网服务提供商(Internet Service Provider)的简称，ISP 有专门的 DNS 服务器应对 DNS 查询请求。
   5. 根服务器：ISP 的 DNS 服务器还找不到的话，它就会向根服务器发出请求，进行递归查询
4. 接着是**建立TCP连接**，进行**三次握手**
5. TCP连接成功后，**发送HTTP请求**
6. 服务器接收到HTTP请求后，经后端应用程序处理，完成后向客户端**返回一个HTTP响应**
7. 浏览器接收到响应后，首先会判断**状态码**是什么，如果 4XX或 5XX 的话就会报错，如果 3XX 的话会进行重定向，如果是 2XX那就继续解析，根据响应头判断是否**缓存**资源。
8. 浏览器开始**解析文件**，如果是 **gzip 格式**的话会先**解压**一下
9. 然后通过文件的编码格式**解码文件**
10. 文件解码成功后，正式开始**渲染**流程，
11. 获取HTML文件，解析构建 DOM 树，与此同时解析CSS构建 CSSOM 树。
12. DOM树和CSSOM树合成 Render 树。
13. 接着进入布局阶段，为每个节点**分配**一个**应出现在屏幕上**的**确切坐标**。
14. 随后调用**GPU进行绘制**，遍历Render Tree的节点，将元素呈现出来。
15. 如果解析过程遇到 `script` 标签的话，默认会阻塞渲染流程，直到JS解析执行完毕，如果存在 `async` 或者 `defer`属性 ，async会并行下载，下载完后立即执行脚本，后者也会并行下载文件，但不会立即执行，会等到HTML解析完成后顺序执行。
16. 当数据传送完毕后，需要断开TCP连接，此时会进行TCP的**四次挥手**。

### 浏览器渲染过程

1. 浏览器获取HTML文件，然后解析，形成**DOM Tree**
2. 与此同时，进行CSS解析，生成CSS对象模型（**CSSOM Tree**）
3. 接着将Dom Tree与CSSOM Tree**合成为Render Tree**
4. 接着进入布局阶段（**Layout**)，为每个节点分配一个应出现在屏幕上的确切坐标
5. 随后调用**GPU进行绘制**，遍历Render Tree的节点，并将元素呈现出来

### DOM Tree是如何构建的

1. 转码，字节流转字符流，将接收到的**二进制数据**按照**指定编码格式**转化为**HTML字符串**
2. 生成Tokens，也就是词法分析，**渲染引擎**将HTML字符串解析成**Tokens**
3. 构建节点，也就是语法分析，完成**标签配对**，**属性赋值**，**确立关系**，**构建节点**；
4. 根据节点，生成**Dom Tree**

### 外什么外链CSS要放在头部，JS要放在尾部

- CSS**放头部**，不影响HTML的解析，可以让**HTML和CSS同时解析**
- 而CSS**放尾部**，要**花费额外的时间**来解析CSS，并且浏览器会先渲染出一个没有样式的页面，等CSS加载完后再渲染成一个有样式的页面，会导致页面出现**闪动**现象。
- JS放尾部是因为浏览器解析到script时会阻塞渲染流程，要等脚本解析执行完毕才继续渲染。
- 可以使用async和defer属性。

### onload、DOMContentLoaded事件的触发顺序

1. DOMContentLoaded事件触发时，**只有DOM加载完成**。
2. onload触发时，页面上所有的**DOM，样式表，脚本，图片**等都已经加载好了。

### 浏览器回流和重绘的区别

- 回流：是指**部分渲染树**或者**整个渲染树**需要**重新分析**，节点尺寸**重新计算**，页面**重新布局**，元素**重新排列**
- 重绘：元素**样式改变**，**不影响布局**，仅是**外观发生改变**。
- 【重绘】不一定出现【回流】，但【回流】一定会出现【重绘】
- 怎么触发
  - 对DOM节点**增删改或移动**
  - display:none**隐藏元素**导致回流，visibility:hidden触发重绘
  - **添加样式**
  - **用户行为**：调整窗口大小，改变字号，滚动页面
- 如何避免
  - 使用class**集中改变样式**
  - 使用**文档片断（documentFragment)**，对DOM**批量操作**，然后**一次性插入**DOM树
  - 对需要设置**动画**的元素，使用绝对定位**脱离文档流**，使它**不影响其它元素**。

### 什么是同源策略，如何实现跨域

- 同源是指“**协议+域名+端口**”三者相同，两个不同域名指向同一IP也属于非同源。
- 它是**浏览器做的限制和约定**，如果没有这种限制，浏览器很容易遭受XSS、CSRF等攻击。
- 有三个标签不受同源策略限制：
  - img标签
  - link标签
  - script标签
- 如何实现跨域
  - JSONP
  - CORS：Access-Control-Allow-Origin响应头
  - 服务器代理
  - websocket
  - postMessage onmessage
  - window.name+iframe
  - location.hash+iframe
  - document.domain+iframe

### 同源页面间的跨页面通信

- 广播模式，将消息发给一个中央站，让中央站通知各页面
  - localstorage， 当localstorage变化时会触发storage事件，可以监听这个事件来实现跨页面通信。
  - BroadCast Channel 广播频道，**同源**的所有页面都onMessage监听同一频道new BroadCastChannel()，其中一个页面发送消息postMessage就会被其它页面收到。
  - Service Worker， 在service worker脚本中自己写监听和发布逻辑
- 共享存储+轮询模式
  - SharedWorker
  - IndexDB
- 窗口传输模式
  - 父窗口调用子窗口的postMessage方法给子窗口传输数据，子窗口通过onmessage接收数据

### Cookie有哪些属性

- name: cookie的名称
- value: cookie的值
- domain: 可以访问此cookie的域名，顶级只能设置和访问顶级，二级可以设置和访问上级和本身
- path：可以访问此cookie的页面路径
- expires/max-age: cookie的过期时间，不设置则为session，浏览器关闭就失效
- size：cookie的大小
- httpOnly：表示cookie不能被脚本获取
- secure：表示只能通过https来传递此条cookie

### 实现即时通讯的方式

1. 短轮询
2. comet技术
3. Server Send Event
4. WebSocket

### CDN的原理

- 最简单的CDN网络由**一台DNS 服务器**和**几台缓存服务器**组成

- 当用户输入URL按下回车，经过**本地DNS系统**解析，会找到一个**CNAME类型的记录**

- **DNS系统**会最终将**域名的解析权**交给**CNAME指向**的**CDN专用DNS服务器**

- 然后会得到**全局负载均衡设备的IP地址**，用户向全局负载均衡设备**发送请求**
- 全局负载均衡设备则**根据用户的IP**选择一台**用户所属区域**的**区域负载均衡设备**
- **区域负载均衡设备**会综合考虑**缓存服务器**离用户的**距离**、**负载情况**、**服务能力**等因素为用户选择一台**最优**的缓存服务器节点，将其**IP**返回给用户

- **用户**向**缓存服务器**发起请求，缓存服务器响应用户请求。
- 如果缓存服务器**没有用户想要的内容**，就向它**上一级缓存服务器**请求内容，直到**追溯**到**源服务器**。
- 解决**网络拥挤**的状况，提高用户访问网站的**响应速度**

### 什么是HTTP

HTTP是**超文本传输协议**（Hyper Text Transfer Protocol），是一种**通信协议**，它允许将**超文本标记语言**（HTML)文档从WEB服务器传送到客户端的浏览器。HTTP协议是构建在**TCP/IP协议**之上的，是TCP/IP协议的一个**子集**。

### HTTP有哪些方法

1. GET， 获取资源
2. POST ，发送数据
3. OPTIONS， 查看资源支持什么方法请求
4. HEAD， 获取请求资源的**头部信息**，如在下载大文件前先获取大小，再决定是否下载
5. PUT， 新增或更新资源
6. DELETE，删除资源
8. CONNECT， 主要**预留给代理服务器**使用，它能够**将连接改为管道方式**
9. TRACE，可结合**max-forwards请求头**可以进行请求**跟踪和诊断**

### GET/POST POST/PUT PUT/PATCH的区别

- GET/POST区别：
  - **数据传输方式**不同：GET将数据放在url，POST数据放在请求体
  - **安全性**不同：GET请求在历史记录缓存中可查，安全性较低
  - **数据类型**不同：GET只支持**ASCII码**的数据类型，而POST无限制
  - **特性**不同：GET是**幂等**的，而POST是**非幂等**
- PUT/POST区别：PUT是更新资源PUT幂等，POST是提交资源POST非幂等
- PUT/PATCH的区别：都是更新资源，PATCH可对资源进行局部更新

### HTTP报文

- 请求报文：
  - 请求行，包括请求方法，URL和HTTP协议版本号
  - 请求头，由键值对组成，每行一对，冒号分隔
  - 空行
  - 请求体，post put等方法携带的数据
- 响应报文
  - 响应行，包括HTTP协议版本，状态码和状态码短语
  - 响应头，由键值对组成，每行一对，冒号分隔
  - 空行
  - 响应体，服务器返回的数据

### HTTP首部

- 通用首部

  - 通用信息性首部字段

    - Connection

      -  控制不再转发给代理的首部字段（即逐跳首部），应用程序会删除报文中所有在Connection首部中出现过的首部，如下示例

        ```
        # 客户端请求首部
        GET / HTTP1.1
        Upgrade:WebSocket
        Connection:Upgrade

        # 经过代理服务器后发送给Web服务器的首部
        GET / HTTP1.1
        ```

      - 管理持久连接

        - Connection:close , HTTP/1.1 默认都是持久连接，使用close后会明确断开连接
        - Connection:keep-alive, HTTP/1.1之前的版本默认都是非持久连接，使用keep-alive可以开启持久连接。

    - Warning: 错误和警告通知

    - Upgrade: 升级为其它协议

    - Date: 创建报文的日期

    - Transfer-Encoding: 报文主体的传输编码格式

    - Trailer: 服文末端的首部一览

    - via：代理服务器的相关信息

  - 通用缓存首部字段

    - Cache-Control: 控制缓存
    - Pragma: HTTP/1.1以前的遗留字段Pragma:no-cache与Cache-Control:no-cache功能一致，只用在客户端发送请求时

- 请求首部

  - Accept
    - Accept: 客户端或者代理能处理的**媒体类型**
    - Accept-Encoding: 优先可处理的**编码格式**
    - Accept-Language:**优先可处理**的自然语言
    - Accept-Charset:优先可处理的**字符集**
    - TE：**传输编码**的优先级
  - 条件请求首部字段
    - If-Match/If-None-Match
    - if-Modified-Since/if-Unmodified-Since
    - if-Range: 如果字段的值ETAG或时间与资源的ETAG或时间一致时，结合Range头进行范围请求，否则返回全体资源。
    - Range：范围请求，只获取部分资源，返回206
    - Expect：期待服务器的特定行为
  - 请求信息性首部字段
    - Host：请求资源所在的服务器
    - From：用户的**邮箱地址**
    - User-Agent：客户端程序信息
    - Referer:请求原始方的url
  - 安全请求首部字段
    - Authorization:web的认证信息
    - Cookie：HTTP/1.1中没有定义，用于客户端**识别和跟踪状态的首部**
  - 代理请求首部字段
    - Max-Forwards:最大的逐跳次数，**只能和TRACE方法**一起使用，每经过一层代理，值减1，如果应用程序收到请求时，首部值为0，则立即返回一条200的响应
    - Proxy-Authorization:代理服务器要求web认证信息

- 响应首部

  - 响应信息性首部字段
    - Age:响应已经产生了多长时间，HTTP/1.1规定缓存服务器在创建响应时必须包含Age首部
    - Location：客户端应重定向到指定URI，主要配合3XX响应码出现
    - Retry-After：告诉客户端多久之后再次发送请求，主要配合**503使用**
    - Server：HTTP服务器的应用程序信息
  - 协商首部字段
    - Accept-Ranges:服务器是否能处理范围请求
    - Vary:
      - 通知客户端，服务端的协商中会使用哪些来自客户端请求的首部
      - 缓存控制，对某次请求，响应报文的Vary中会指定一些首部名称，客户端后续请求相同资源时，这些首部与缓存的那次请求完全一致时才会返回缓存资源
  - 安全响应首部字段
    - WWW-Authenticate/Proxy-Authenticate:服务器/代理服务器要求客户端的验证信息
    - Set-Cookie：非HTTP/1.1标准首部，**服务端向客户端设置Cookie**

- 实体首部

  - 实体信息性首部字段
    - Allow：通知客户端可以对指定资源使用哪些HTTP方法
  - 内容首部字段：
    - Content-Encoding
    - Content-Language
    - Content-Length
    - Content-Location:报文主体部分相对应的URI
    - Content-MD5：
    - Content-Range
    - Content-Type
  - 实体缓存首部字段
    - ETag
    - Expires
    - Last-Modified

### HTTP的keep-alive是干什么的

- 在**HTTP/1.0**版本，每次HTTP请求都要建立一个连接。
- **创建连接**需要**消耗资源和时间**，为了减少资源消耗缩短时间，就需要**重用连接**。
- 在**请求头中**加入**Connection: keep-alive**就可以告诉对方这个请求**响应完成后**不要关闭连接，下次还用这个请求继续交流。
- 优点：

1. 打开的连接少了，**CPU和内存**的使用会减少
2. **减少**后续请求的**延迟**

### HTTP状态码

- 1xx：信息状态码
  - 101 **协议变更**
- 2xx：成功状态码
  - 200 OK，表示请求成功
  - 201 Created， 请求**已被实现**，而且有一个**新的资源已经依据请求需求而建立**
  - 202 Accepted，请求**被接受**，**但还没执行**，不保证完成请求
  - 204 No content，请求成功，但**响应报文不含任何主体部分**
  - 206 Partial Content， **进行范围请求**
- 3xx：重定向
  - 301 moved permanently，**永久性**重定义
  - 302 found, **临时性**重定义
  - 303 see other，表示**资源存在另一个URL**，应使用get方法定向获取资源
  - 304 not modified， 一般是**命中协商缓存**时使用
- 4xx：客户端错误
  - 400 bad request，**请求报文语法**错误
  - 401 unauthorized，**需要认证信息或认证失败**
  - 403 forbidden，资源**禁止访问**
  - 404 not found，**资源不存在**
- 5xx：服务端错误
  - 500 internal server error，**服务端内部错误**
  - 502 bad gateway，**网关或代理服务器**从**上游服务器**获取的**响应无效**
  - 503 service unavailable， 服务器处理**超负载或正在维护**

### 说说HTTPS

- HTTP协议数据都是**明文进行传输**的，**缺乏安全**性，而**HTTPS**就是为了**解决HTTP的不安全**的问题，在应用层和传输层中添加了一个**SSL或TLS**加密协议。
- HTTPS如何保证安全？
  - **对称加密**是通信双方都使用同一个秘钥进行加解密。无法解决首次把秘钥发给对方的问题，因为容易被黑客拦截。
  - **非对称加密**就是有一个密钥对，公钥和私钥，公钥加密私钥解密，或者私钥加密公钥解密。
  - HTTPS则是**结合这两种加密方式**。首先服务端将公钥发送客户端，接下来客户端创建一个秘钥，然后通过公钥加密并发送给服务端，服务端接收到密文以后通过私钥解密出正确的秘钥，然后双方就可以使用这个秘钥通过对称加密方式交流了。
  - 但这样仍存在一个问题，就是在一开始服务器发送公钥的时候，中间人把公钥换成自己的公钥再给客户端，客户端用中间人的公钥加密那个用于对称加密的秘钥后发给客户端的时候，中间人再次拦截用自己的私钥来解密，又可以得到这个用于对称加密的秘钥，破解通信双方发送的数据。
  - 这时就需要一个安全的第三方颁发的证书，客户端在第一次接收公钥时通过这个证书证明发送方的身份，防止被中间人攻击。
  - 证书验证方式：证书颁发机构会先用证书指定的算法对证书内容进行HASH运算得到一串摘要，再用机构自己的私钥加密，组成数字签名签署在证书上，服务器将这个证书发送给客户端，客户端使用机构的公钥对数字签名进行解密得到摘要，然后使用证书上的算法对内容进行HASH也得到一串摘要，对比两个摘要就知道证书是否被中间人篡改。

### TLS握手过程

实际上TLS握手的过程是通信双方在协商使用什么加密方式和生成密钥的过程。

- 客户端发送一个随机值**random1**以及自己支持的加密方式给服务端。
- 服务端收到客户端的随机值random1，自己也产生一个随机值**random2**，然后将random2以及自己的证书发送给客户端。
- 客户端收到服务端的**证书**并**验证**是否有效，验证通过会再生成一个随机值**random3**，通过服务端证书的公钥去加密这个随机值random3并发送给服务端。
- 服务端收到加密过的随机值random3并使用私钥解密获得第三个随机值，这时候两端都拥有了三个随机值，可以通过这三个随机值按照之前约定的加密方式**生成密钥**，接下来的通信就可以通过该密钥来加密解密
- 在 TLS 握手阶段，两端使用非对称加密的方式来通信，但是因为非对称加密损耗的性能比对称加密大，所以在正式传输数据时，两端使用对称加密的方式通信。

### HTTP1.1和HTTP1.0的区别

- **缓存**处理：
  - 1.0中主要使用expires和last-modify/if-modified-since
  - 1.1引入了更多的缓存控制策略Cache-control Etag If-none-match/If-match/if-Unmodified-since
- **带宽优化**及网络连接的使用：
  - 1.0存在一些浪费宽度的现象，比如只需要一部分数据，服务端却全部返回；不支持**断点续传**
  - 1.1引入range头部，可以进行**局部请求**（206）
- 错误通知的管理
  - 1.1中**新增了24个错误状态码**
- **Host**头处理：
  - 1.0请求中没有传递host，由于认为每台服务器都绑定一个唯一的IP地址，但随着虚拟主机技术的发展，在一台物理服务器上可以存在多台虚拟主机共享同一个IP
  - 1.1请求中必须要有host，不然会返回400的响应码
- **长连接**：
  - 1.1支持持续连接和请求管线化，在一个TCP连接可以传送多个HTTP请求和响应，默认开启**Connection:keep-alive**
  - 1.0要手动开启keep-alive

### 说说HTTP2

相对于HTTP1有以下优势 ：

1. 二进制传输：HTTP1.0是通过**文本的方式**传输数据，2.0采用**二进制格式编码**进行传输，**速度更快**。
2. 多路复用：**一个TCP连接**中可以**存在多个请求**，**接收方**可以通过**帧中的标识**来分辨是哪个请求，解决了**队头阻塞**的问题，**提高传输效率**。
3. 头部压缩：2.0对**报文头部**进行了**压缩**，并在两端维护了**索引表**，记录出现过的header，头部键值没变可以只传输键名，**减少头部大小，提高了传输效率**。
4. 服务端推送：服务端可以**在客户端的某个请求后**，**主动推送**其它资源。

### 说说HTTP缓存

良好的缓存策略可以**降低资源的重复加载**，**提高网页的整体加载速度**。

缓存策略可分为强缓存和协商缓存：

- **强缓存**，可以通过两个响应头来实现
  - Expires，它是**HTTP/1.0的规范**，值是一个**GMT格式的时间字符串**，表示资源的有效期，当再次请求该资源时，会去判断当前时间是否超过有效期，如果没有超过就会命中强缓存，返回状态码200，使用缓存资源，如果超过了说明缓存可能已经过期了，将使用协商缓存。
  - Cache-Control: 它是**HTTP/1.1的规范**，**优先级高**于Expires，它可设置**max-age**的值，这个值的单位是秒，表示在N秒内再次请求资源会使用强缓存，否则会使用协商缓存。
- **协商缓存**，会去请求服务器验证当前缓存是否新鲜，它也有两种实现方式
  - Last-Modified（值为资源最后更新时间，随服务器response返回）
  - If-Modified-Since（通过比较两个时间来判断资源在两次请求期间是否有过修改，如果没有修改，则命中协商缓存）
  - ETag（表示资源内容的唯一标识，随服务器response返回）
  - If-None-Match（服务器通过比较请求头部的If-None-Match与当前资源的ETag是否一致来判断资源是否在两次请求之间有过修改，如果没有修改，则命中协商缓存）

### 说说TCP和UDP

- TCP是**面向连接**的，**1对1**通信，**传输可靠**，**有序**，**可拥塞控制**，但传输速度相对**慢**，**量级较低**，**头部**占**20-60个字节**
- UDP是**无连接**的，能提供**单播，多播，广播**的功能，**传输不可靠**，**无序**，**不能进行拥塞控制，易丢包**，但传输**速度快**，**量级较高**，**头部**大小仅占**8字节**。
- TCP的特性：
  - 提供一种**面向连接**的、可靠**字节流**服务
  - 一个TCP连接只有**两方**进行通信
  - 通过**校验和，确认和重传机制**来**确保传输的可靠性**
  - 对数据**分节排序**，使用**累积确认保证顺序和去重**
  - 使用**滑动窗口机制**来实现**流量控制**，通过**动态改变窗口大小**进行**拥塞控制**

### OSI七层模型

- 应用层：包括**各种应用程序协议**，如HTTP FTP 邮件相关协议
- 表示层：负责**加解密**，**压缩解压**，**转换翻译**
- 会话层：负责**建立和管理会话**
- 传输层：负责对数据进行**必要的分割**，传输**数据包**，包括TCP UDP
- 网络层：负责**逻辑编址**，**路由选择**，**分组传输**
- 数据链路层：负责**物理寻址**，将**原始比特流**转为**逻辑传输线路**
- 物理层：负责**电子机械通信信道**上的**原始比特流传输**

### 说说TCP的三次握手和四次挥手

- 三次握手
  - 第一次握手，客户端向服务端发送一个SYN=1，SEQ=X的包，客户端进入**SYN_SENT**状态
  - 第二次握手，服务端向客户端发回一个SYN=1，ACK=1，ack_num为X+1，SEQ=Y的包，服务端进入**SYN_REVD**状态
  - 第三次握手，客户端再次向服务端发送一个ACK=1，ack_num=Y+1的包，TCP连接建立完成。
- 四次挥手
  - 第一次挥手：假设客户端想关闭连接，客户端发送一个**FIN**=1，**SEQ**=X的包，表示自己没有数据可以发送，但可以接受数据，客户端进入**FIN_WAIT_1**状态
  - 第二次挥手：服务端接收后，发送一个**ACK=1**，**ack_num=X+1**的确认包，表示自己接受了客户端的关闭连接请求，但还没有准备好关闭连接，服务端进行**CLOSE_WAIT**状态，客户端接收到确认包后，进行**FIN_WAIT_2**状态，等待服务器关闭连接
  - 第三次挥手：服务端准备好关闭连接时，向客户端发送一个**FIN=1，SEQ=Y**的包，服务器进入**LAST_ACK**状态，等待客户端的最后一次确认
  - 第四次挥手：客户端接收到服务端的关闭请求，会向服务器发送一个**ACK=1，ack_num=Y+1**的确认包，并进入**TIME_WAIT**状态，等待可能出现的要求重传的ACK包，服务器端接收到这个包后，会关闭连接，进入**CLOSED**状态，客户端会等待**两个最大段生命周期**的时间，没有收到ACK包，就认为服务器正常关闭连接，于是自己也关闭连接，进入CLOSED状态。

### WEBSOCKET握手过程

Websocket**基于TCP协议，兼容http协议，作为H5的一部分**，**作用**就是在**服务端**和**客户端**之间建立**实时双向通信**

优点：**性能好**，**延迟低**

缺点：**复杂度高**，项目**改造成本大**，**不兼容低版本浏览器**

WebSockets**包括**：

- **握手阶段**
  - **握手请求**，实际上是一个**HTTP GET请求**，**协议版本至少是1.1**，**请求头**比普通请求**多了一些字段**
    - Connection：值为Upgrade，告诉服务器当前请求是一个**协议升级请求**
    - Upgrade：值为websocket，表示我要升级成ws协议
    - Sec-Websocket-Version：值必须是13
    - Sec-Websocket-Key：**握手key**，主要用来**校验**，验证成功后才能**建立连接**
    - Sec-Websocket-Protocol：表示**客户端**可接受的**子协议类**，服务端**要返回其中一个子协议**。
  - **响应**，状态码为101，表示发生了**协议变换**，**响应头**中包含
    - Upgrade和Connection，表示**同意升级**并**使用ws协议**
    - Sec-WebSocket-Accept，服务端将**请求头中的key**进行**加密**后得到的值，表示**服务器同意建立连接**
    - Sec-WebSocket-Protocol，服务器选择的一个**子协议**
- **数据传输阶段**
  - new Websocket(url) 握手
  - ws.onopen 指定握手连接成功的回调
  - ws.onerror 指定连接失败的回调
  - ws.onclose 指定连接关闭的回调
  - ws.send 发送信息
  - ws.onmessage 指定接收服务端消息的回调

### 前端安全问题

- XSS：Cross-site Scripting，**跨站脚本攻击**，**攻击者**通过在目标网站**注入恶意的js脚本**，使它在用户的浏览器上运行
  - **存储型**，**数据库中保存了恶意脚本**，**取出时**直接被**拼接到HTML**中，**恶意脚本被执行**
  - **反射型**，攻击者**构建**出一个含有**恶意脚本的URL**，**用户打开后**被**拼接到HTML**中，恶意脚本**被执行**
  - 防御的方式：
    - 对特殊字符**转义**，如引号，尖括号，斜杠等
    - 对文本内容及长度做**限制**
- CSRF：Cross-site Request Forgery，**跨站请求伪造**，攻击者利用**用户的登录信息**伪造身份发送**恶意请求**实现敏感操作。
  - 如何防御：
    - **GET**请求不对数据进行修改
    - 利用**cookie响应头的SameSite属性**禁止第三方网站访问到用户的**Cookie**
    - 利用**Referer**请求头阻止第三方网站请求接口
    - 请求时附带验证信息，如**验证码**或者**token**

## 前端工程化和优化

### 性能监控平台如何捕获错误

1. 可疑区域增加 Try-Catch
2. 全局监控 JS 异常 window.onerror
3. 全局监控静态资源异常 window.addEventListener
4. 捕获没有 Catch 的 Promise 异常：unhandledrejection
5. VUE vue.config.errorHandler
6. 监控网页崩溃：window 对象的 load 和 beforeunload
7. 跨域 crossOrigin 解决

### 首屏优化

可以从三方面进行考虑

- **降低请求量**
  - 代码**压缩**，资源**合并**，开启**缓存**
  - 小图片使用base64的方式
  - 图片**懒加载**
  - 模块**按需加载**
  - 路由**动态加载**
  - vue使用**keep-alive**
  - **服务端渲染**
- **加快请求速度**
  - 使用**HTTP2.0**协议
  - 使用**CDN**
- **增强用户体验**
  - 使用**loading**提示
  - 使用**骨架屏**

### 怎么做前端性能优化？

1. 网页内容
   - 减少HTTP请求次数
   - 减少DNS查询次数
   - 避免页面跳转
2. 服务器
   - 使用CDN
   - 使用HTTP2.0
   - 开启缓存
3. JS
   - 脚本置底
   - 代码打包压缩，去除重复脚本
   - 减少DOM操作，减少回流重绘
4. CSS
   - 样式表置顶
   - 避免使用@import
   - 避免使用CSS表达式
5. 图片
   - 使用雪碧图
   - 避免空的图片src
   - 图片懒加载

### babel的原理

babel实际上是一个语言编译器，作用就是代码转换成预期的结果，转换代码的过程主要分三步：

1. 解析：使用`babylon`解析器将输入的JS代码解析生成**抽象语法树**（AST），即**词法分析和语法分析**的过程；
2. 转换：通过**babel-traverse**对AST进行遍历，然后通过一定的规则（这个规则根据实际需求定）对AST节点进行增删改等转换操作；
3. 生成：使用**babel-generator**模块将变换后的AST再转换为JS代码。

### webpack的原理（构建过程）

Webpack是基于**模块化**的打包工具，通过**递归**的方式构建一个**依赖关系图**，包含了所有程序需要的模块，然后将这些模块**打包**成**一个或多个bundle文件**。

- 根据**配置文件**和**Shell语句**中**获取合并**参数，得到**最终参数**
- 初始化**Compile对象**，加载所有**插件**，执行**run方法**开始**编译**
- 从配置中获取entry**入口文件**
- **从入口文件出发**，**递归**查出**依赖的模块**，同时使用**Loader**对模块进行**翻译**
- 得到**翻译后的结果**和**依赖关系图**
- **根据入口文件和模块间的依赖关系**，**组装成**一个个**包含多个模块的chunk**，将chunk**转换**成**独立的文件**，放入**输出列表中**
- **确定好输入列表**后，根据配置中的**输出路径和文件夹**，将文件内容**写到文件系统**中。

以上过程中，webpack会在特定的时间点广播出特定的事件，插件在监听到感兴趣的事件后会执行特定的逻辑，可以调用webpack提供的API改变webpack的输出结果。

### webpack和gulp的区别

- Gulp是基于**任务**的工具，**自动执行**指定的任务，如同**流水线**，把资源放上去然后**通过不同插件进行加工**，最后**输出**加工后的资源。
- Webpack是基于**模块化**的打包工具，**自动化处理模块**，webpack会**递归地**构建一个**依赖关系图**，包含应用程序需要的每个模块，然后将这些模块**打包**成**一个或多个bundle文件**。

### bundle，chunk和module是什么

- bundle：是webpack**打包**出来的文件
- chunk: 是**代码块**，一个chunk由多个模块组合而成，用于**代码的合并和分割**
- module:是开发中的单个**模块**，webpack会从配置的entry入口开始递归找出所有依赖的模块

### loader和plugin的区别

- 不同的作用：
  - Loader为加载器，webpack**只认识JS文件**，如果想将其它文件也打包的话，就会用到loader，它的作用就是**让webpack拥有加载解析非JS文件的能力**。
  - Plugin为插件，可以**扩展webpack的功能**，在webpack运行的**生命周期**中会发布出很多事件，Plugin可以通过**监听**这些事，**调用**webpack的**api改变输出的结果**。
- 不同的用法：
  - Loader在**modules.rules**中配置，也就是说，它作模块的**解析规则**而存在。类型为数组，每一项都是一个对象，里面描述了对于什么类型的文件，用什么加载器和参数进行解析加载。
  - Plugin在**plugins**中单独配置。类型为数组，每一项是一个plugin实例，参数通过构造函数传入。

### 常用的loader

- **file-loader**：把**文件输出**到一个文件夹中，在代码中通过**相对URL**去**引用**输出的文件
- **url-loader**：和file-loader类似，能在**文件很小的情况下**以**base64**的方式把文件内容**注入到代码**中
- **vue-loader**: 能够让webpack解析**Vue的单文件组件**
- source-map-loader：加载额外的Source Map文件，以方便断点调试
- **image-loader**：**加载并压缩图片**文件
- **babel-loader**:**把ES6转换成ES5**
- **css-loader**:加载CSS，支持**模块化**、**压缩**、**文件导入**特性
- **style-loader**:把**CSS代码注入到js**中，通过DOM操作去加载CSS

### 常用的plugin

- **define-plugin**:定义**环境变量**
- html-webpack-plugin:**简化HTML文件创建**
- uglifyjs-webpack-plugin:通过**uglifyjs压缩代码**
- mini-css-extract-plugin:将**CSS提取**到单独的文件中，支持**按需加载**

### 如何编写loader和plugin

- Loader
  - Loader就像一个**翻译官**，把读到的源文件内容**转义**成新的文件内容，并且每个Loader通过**链式操作**，将源文件**一步步翻译**成想要的样子。
  - 编写Loader要**遵循单一原则**，每个Loader只做一种“翻译”工作。
  - 输入给Loader的是源文件内容source，通过返回值的方式将处理后的内容输出，也可以调用this.callback()方法，将内容返回给webpack。还可以通过this.aysnc()生成一个callback函数，再用这个callback将处理后的内容输出。此外webpack为开发者提供了开发loader的工具函数集——loader-utils。
- Plugin
  - webpack在**运行的生命周期会发布很多事件**，Plugin通过监听这些事件，调用webpack的api改变输出结果。

### 如何用webpack来优化前端性能

- **代码压缩**：删除多余代码、注释、简化代码写法。如UglifyJsPlugin压缩JS文件，利用css-loader的minimize来压缩css
- **利用CDN加速**：在构建过程中，将引用的静态资源路径修改为CDN上对应的路径。可以利用webpack对于`output`参数和各loader的`publicPath`参数来修改资源路径
- **Tree-shaking**：剔除永远不会走到的代码片断
- **Code Spliting**:将代码按路由维度或组件分块，按需加载，同时可以充分利用浏览器缓存
- **提取公共第三方库**：SplitChunksPlugin插件可以对公共模块抽取，利用**浏览器缓存**可以长期缓存这些**无需频繁变动的公共代码**。

### 如何提高webpack的打包速度

- **提取公共文件**：多入口情况下，使用CommonChunkPlugin
- 外部扩展：通过**externals**配置来提取常用库，将不怎么需要更新的第三方库脱离webpack打包，不被打入bundle中，从而减少打包时间，如jQuery用script标签引入
- **dll**：利用DllPlugin和DllReferencePlugin预编译资源模块，让一些基本不会改动的代码先**打包成静态资源**，避免反复编译
- 利用**缓存**：webpack.cache、babel-loader.cacheDirectory、HappyPack.cache都可以利用缓存提高rebuild效率
- 缩小文件搜索范围：比如babel-loader插件，如果你的文件仅存在于src中，那么可以设置include:path.resolve(__dirname,'src')

- happypack**多线程编译**：利用进程并行编译loader，利用缓存来使得rebuild更快，类似的替代者是thread-loader
- 提升**代码压缩**速度：webpack-uglify-parallel,**多核并行压缩**
- 使用Tree-shaking和Scope Hoisting**剔除多余**代码。

### 怎么配置单页应用和多页应用

- 单页应用：直接在**entry**中指定单页应用的入口即可
- 多页应用：可以使用webpack的AutoWebPlugin插件来完成简单自动化的构建，但是前提是项目的目录结构必须遵守它预设的规范
  - 每个页面都有公共的代码，可以将这些代码抽离出来，避免重复加载
  - 随着业务不断扩展，页面可能会不断追加，所以一定要让入口的配置足够灵活，避免每次添加新页面还需要修改构建配置

### git工作流是怎样的

GitFlow是一个git操作流程标准，包含如下如个关键分支：

| 名称        | 说明                                                         |
| ----------- | ------------------------------------------------------------ |
| **master**  | **主分支**                                                   |
| **develop** | **主开发**分支，包含确定**即将发布的代码**                   |
| **feature** | **新功能**分支，一般一个新功能对应一个分支，对于功能的拆分需要比较合理，以避免一些后面不必要的代码冲突 |
| **release** | **发布**分支，发布时候用的分支，一般测试时候发现的 bug 在这个分支进行修复 |
| **hotfix**  | hotfix 分支，**紧急修 bug** 的时候用                         |

feature分支都是从develop分支创建的，完成后再合并到develop分支，等待发布

当需要发布时，我们从develop分支创建一个release分支

然后这个release分支会发布到测试环境进行测试，如果发现问题就在这个分支直接进行修复

在所有问题修复之前，我们会不停地重复发布->测试->修复->重新发布->重新测试这个流程

发布结束后，这个release分支会合并到develop和master分支，从而保证不会有代码丢失

master分支只跟踪已经发布的代码，合并到master上的commit只能来自release分支和hotfix分支

hotfix分支的作用是紧急修复一些Bug，它们都是从master分支上的某个tag建立，修复结束后再合并到develop和master分支上

### rebase与merge的区别

二者都是用于**从一个分支获取并且合并到当前分支**。

merge会自动**创建一个新的commit**

rebase会**合并之前的commit历史**
