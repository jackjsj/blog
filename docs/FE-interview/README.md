---
sidebar: auto
---

# 前端面试题

## HTML

### SEO（搜索引擎优化，Search Engine Optimization）

前端需注意的SEO有：

- 合理使用`title`、`description`、`keywords`：这三项的权重逐个减小；
- 语义化的`HTML`代码：让搜索引擎更容易理解网页；
- 重要的`HTML`代码要放在最前：搜索引擎抓取`HTML`顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容优先被抓取；
- 重要内容不要用`js`输出并且少用`iframe`：爬虫不会执行`js`，也不会抓取`iframe`中的内容；
- 非装饰性图片必须加`alt`属性；
- 提高网站**速度**：网站速度是搜索引擎排序的一个重要指标

### doctype的作用

- DOCTYPE是HTML的**标准声明**，必须声明在HTML文档**第一行**。它的作用是**告知**浏览器解析器用什么文档标准来解析页面。
- 有两种解析模式：标准模式和怪异模式。
  - 标准模式是使用**W3C**的标准解析渲染页面。
  - 怪异模式是用浏览器**自己的标准**解析渲染页面，不同浏览器看到的渲染结果不同，**不声明DOCTYPE就会使用怪异模式**。

### HTML、XML和XHTML的区别

- HTML是**超文本标记语言**，在HTML4.0**前先有实现后有标准**，导致HTML非常混乱和松散
- XML是可**扩展标记语言**，主要用来**存储数据**，可以扩展。
- XHTML是**可扩展超文本标记语言**，基于HTML和XML，W3C用它来解决HTML的混乱问题，并基于此诞生了**HTML5**，在开头加了DOCTYPE声明，开启标准模式。

### HTML5新特性

1. H5文档声明类型**仅有一型**，即`<!DOCTYPE HTML>`，**不再基于SGML**，不需要引用**DTD**
2. **新元素标签**，如**语义化标签**header, footer, section, nav, aside，**多媒体标签**video, audio, canvas
3. **input元素**添加了**新的类型**，如date, time, email等。
4. 添加了**新的技术**，如`WebWorker`、`Websocket`、`Geolocation`
5. **新增属性**和指定了**全域属性**, 比如meta标签的charset属性, script标签的defer和async属性，全域属性包括id, tabindex, repeat。
6. H5**移除**了一些元素，如big, center, font, frame等等

### 什么是HTML语义化

HTML语义化就是**使用适当语义**的HTML标签，让页面具有**良好的结构和含义**。

它的好处主要有两点：

1. 对开发者友好，**增强代码可读性**，**便于团队开发和维护**
2. 对机器友好，适合搜索引擎的**爬取有效信息**，**支持读屏软件**，**根据文档生成目录**等。

### 常用meta标签有哪些

meta标签用来**描述HTML文档元信息**，例如**描述**，**关键字**，**作者**，**日期时间**等。

常用的meta：

1. 比如`charset`，设置**文档编码形式**
2. `http-equiv`, 设置**http的文件头**，如设置http缓存过期时间
3. `viewport`，常用于**移动开发**，可以**控制视口的大小和比例**等。

```html
<meta name="viewport" content="width=device-width，initial-scale=1，minimum-scale=1, maximum-scale=1，user-scalable=no">
<!-- 不缓存当前页面的设置 -->
<meta http-equiv=”pragma” content=”no-cache”>
<meta http-equiv=”cache-control” content=”no-cache”>
<meta http-equiv=”expires” content=”0″>
```

### src和href的区别

- src
  - 指向**外部资源的位置**；
  - 会将指向的内容**下载并会嵌入**到标签所在位置；
  - 当浏览器解析到这个元素时，**会暂停其它资源下载和处理**，直到资源加载、编译、执行完毕。（不一定准确，chrome中多个js资源的下载是并行的）
- href
  - 指向**网络资源的位置**
  - 用来**建立**当前元素与文档间的**链接**
  - 当浏览器识别到它指向的文件时，会并行下载资源，**不会停止对当前文档的处理**。

### img标签的title和alt有什么区别

- `title`是当鼠标悬浮在元素上的时候显示
- `alt`是的特有属性，是图片内容的等价描述，当图片无法加载时显示、可用于读屏器阅读图片，提高图片的访问性，非装饰性图片都必须设置有意义的值，有利于SEO。

### Canvas和SVG的区别

- `svg`绘制出来的每一个图形的元素都是独立的`DOM`节点，而`canvas`输出的是一整幅画布。
- `svg`输出的图形是矢量图形，能修改参数自由放大缩小，不会失真。而`canvas`输出的画布就像一张图片，放大时会失真。

### script标签的defer和async的区别

- 默认遇到script标签会停止HTML解析，等待脚本**加载执行完毕**后，才继续解析文档。
- 加async属性，脚本会**异步加载**，加载完后立即执行，阻塞HTML解析，而且不能保证脚本执行顺序
- 加defer属性，脚本也会异步加载，但不会立即执行，会等到HTML解析完成后再执行，能保证脚本执行顺序。

### 前端存储方式

有五种存储方式，分别是cookie, localStorage, sessionStorage, indexDB, webSQL。

1. cookie的优点就是兼容性好，使用方便。缺点是大小只有4KB，请求头自带cookie浪费流量，每个domain的cookie个数有限制。
2. localStorage和sessionStorage差不多，一个是永久存储，除非手动删除，一个是会话级存储，即页面关闭数据就没了。
3. indexDB是H5的数据库储存方案，用key-value进行存储，用JS操作方便
4. webSQL已被W3C废弃，属于关系型数据库，用SQL操作，较为繁琐，用得较少。

## CSS

### CSS选择器优先级

- 内联>id>class>tag

### link和@import的区别

1. link是标签，可以用DOM操作，@import是CSS提供的，不能用DOM操作。
2. link引入的资源会在页面加载时加载，而@import引用的CSS会等到页面加载完才加载
3. link无兼容问题，@import只在IE5以上才能识别

### CSS隐藏元素的方式和区别

- display:none: 不占空间，不可交互
- visibility:hidden：占空间，不可交互
- opacity:0：占空间，可交互
- transform:scale(0,0)：占空间，不可交互

### CSS有几种定位方式

- 五种，分别是static\relative\absolute\fixed\sticky

### 盒模型

标准盒模型和IE盒模型，标准盒模型的宽高就是内容的宽度，而IE盒模型的宽高是内容+内边距+边框后的结果。

### 伪元素和伪类

- 伪元素是不存在于文档树中的元素，通过给它添加样式来实现一些效果，如before,after
- 伪类表示元素的某种特定状态，如active, hover

### BFC

- BFC**块级格式化上下文**，是页面中一块独立的渲染区域，有一些渲染规则和特性，决定了它的子元素如何布局，它内部的元素与外部的元素相互隔离。
- 符合一些条件就可以触发BFC：
  - 根元素
  - 浮动元素
  - position为absolute或fixed的元素
  - overflow不为visible的元素
  - display为inline-block\table-cell\table-caption\flex\inline-flex的元素等
- BFC有一些特性，比如：
  - BFC内部盒子会在垂直方向**一个接一个**地排列
  - BFC内部盒子**垂直方向的距离**由外边距决定，同属一个BFC的相邻盒子垂直外边距会重叠
  - BFC内部盒子的margin左边与包含块border左边**相接触**，即使存在浮动也是如此
  - BFC区域不会与**其它浮动盒子**发生重叠
  - BFC**计算高度**的时候，浮动盒子也参与计算
- 根据这些特征，我们常用BFC来
  - 实现**双栏**自适应布局
  - **清除浮动**
  - 解决**外边距塌陷**问题

### 媒体查询

- 媒体查询是网页对**不同型号设备**做出**适配**的**响应式设计方案**。
- 媒体查询包括
  - 可选的媒体类型
  - 若干表达式，这些表达式描述了媒体特征，如果满足这些特征，媒体查询内的样式就会被使用。

### z-index和层叠上下文

- 层叠上下文元素会提升为一个比较特殊的图层，在三维空间中比普通图层高出一等

- 符合一些条件可以触发层叠上下文：

  - html根元素
  - z-index不是auto的定位元素
  - flex项目元素
  - 设置了一些css3属性的元素
    - opacity小于1
    - transform/filter/perspective不为none的元素

- 它有一些特性：

  - 层叠上下文可以嵌套，内部层叠上下文和它的子元素都受制于外部的层叠上下文
  - 每个层叠上下文和兄弟元素相互独立
  - 每个层叠上下文自成一体，整个元素可以认为是在父层叠上下文中的顺序中。

- 层叠上下文在z轴上的排列有一定的规则，也就是层叠顺序，可分为七层：

  1. 层叠上下文

  2. 负的z-index元素

  3. block块级元素

  4. float元素

  5. inline/inline-block元素

  6. z-index为auto或为0的元素

  7. 正的z-index元素

## Javascript

### 原型和原型链

1. 几乎所有**函数**都有一个prototype属性，它会指向这个函数创建的**实例对象**的原型
2. **实例对象**也会有一个`__proto__`属性指向自己的隐式原型。(`Person.prototype === person.__proto__`)
3. 原型是个对象，它有一个 `constructor` 属性指向构造函数本身
4. 原型有以下特点：
   - 原型对象上添加属性，所有实例都会共享这些属性
   - 在对象上查找自身没有的属性时，会从对象的原型上找，找不到就找原型的原型，一直找到 Object.prototype，找不到就返回undefined
5. 原型链就是查找对象属性时所形成的链式结构。

### 作用域和作用域链

1. 代码**定义变量**的区域，它规定了**如何查找**变量，确定当前执行代码对变量的**访问权限**。
2. 根据代码所在的位置可分为：全局、函数和 eval 作用域。
3. JS 是**静态作用域**，函数的作用域在函数创建的时候就已确定。
4. 作用域可**嵌套**，在查找变量时，先从当前作用域中查找，找不到就在外层的作用域中找，一直找到全局作用域，找不到就报错。
5. **逐层嵌套**的作用域形成的链式结构就是作用域链。

### 闭包

1.  函数嵌套，内部函数引用了外部函数的变量，这样就能产生闭包；
2.  闭包有两种理解：
    - 这个内部函数就是闭包
    - 闭包是包含引用变量的对象，谷歌浏览器debugger时可以看到这个closure对象。
3.  闭包的作用
    - 延长了引用变量的生命周期
    - 让外部可以使用函数内部的变量，突破了作用域的限制
4.  闭包的缺点
    - 变量未释放会占用内存
    - 滥用闭包会导致内存泄漏

### this 的指向

1. 默认情况，非严格模式，this 指向全局对象
2. 在函数中 this 一般指向调用该函数的对象
3. 使用 call,apply,bind 方法可显式指定 this 的指向
4. 使用 new 调用构造函数，函数中的 this 指向新创建的实例对象
5. 箭头函数没有自己的 this，函数中的 this 指向箭头函数所在的上下文中的 this

### js 执行机制

一段JS代码的运行可分为两个阶段：

- 编译阶段，先进行分词/词法分析，再进行解析/语法分析，最后进行预编译
- 执行阶段，js代码并非简单的一行行解释执行的，而是将js代码分为一块块的可执行代码块进行执行，可分为三类，分别是
  - 全局代码块
  - 函数代码块
  - eval代码块

JS引擎由两个主要部分组成：

- 内存堆：是内存分配地址的地方
- 调用栈：是代码执行地方

在代码块执行前会先创建执行上下文，三种代码块会对应三种执行上下文，分别是全局、函数和eval执行上下文。

- 全局执行上下文，任何不在函数内部的代码都在全局上下文中，一个程序只有一个全局上下文，它会执行两件事：
  - 创建一个全局的window对象
  - 设置this的值等于这个全局对象
- 函数执行上下文，每当一个函数被调用时，都会为这个函数创建一个新的执行上下文。
- 在执行eval内部的代码时也会创建它自己的执行上下文。

> 在js引擎首次读取代码时，会创建一个全局执行上下文并将其推入当前的执行栈。每当发生一个函数调用，引擎都会为该函数创建一个新的执行上下文并将其推到当前执行栈顶端。引擎会运行执行上下文栈顶端的函数，当此函数运行完成后，其对应的上下文将会从执行栈中弹出。最终执行栈中的上下文会被清空，这时所有代码执行完毕。

执行上下文的创建可分为两个阶段：

- 创建阶段，主要做一些准备工作
- 执行阶段，主要工作就是给变量赋值

创建阶段做的准备工作包括三点：

- 决定this的指向
- 创建词法环境
- 创建变量环境

词法环境包括两个部分，环境记录器和外部环境的引用

- 环境记录器是存储变量和函数声明的实际位置
- 外部环境的引用是指它可以访问其父级词法环境，也就是作用域。

词法环境分三大类：

- 全局环境，全局环境的外部引用是null，它拥有全局对象，比如window对象，还有用户定义的全局变量，并且this值指向全局对象。
- 模块环境，包含模块顶级声明的绑定以及模块显式导入的绑定，模块环境的外部引用是全局环境。
- 函数环境，函数内部用户定义的变量存储在环境记录器中，外部引用既可以是其它函数的内部词法环境，也可以是全局环境

变量环境也是一个词法环境，不同的是词法环境用来存储函数声明和变量（let和const)的绑定，而变量环境只用来存储var变量绑定。

### null 与 undefined 的区别

- `undefined`表示变量**声明了，未赋值**。
- `null`表示**赋值了，值为空**，将变量赋值为null可用来**主动释放**对象的引用。

### == 和 === 的区别

- === 判断类型和值是否相同，对象类型比较的是内存地址值。
- 用==判断时，如类型相同，会去使用===判断，如类型不同会做隐式类型转换，具体判断流程如下：
  - 判断是否对比` null `和 `undefined`，是就返回 true
  - 判断是否对比 `string `和 `number`，是就将 string 转成 number 再比较
  - 判断其中一方是否为` boolean`，是就将 boolean 转成 number 再比较
  - 判断其中一方是否为 `object`，且另一方为 string，number，symbol，是就把 object 转成原始类型。

### 为什么会有bigint提案

- js所有数字都保存成64位浮点数，这给数值的表示带来两大限制。
  - 一是数值的精度只能到53个二进制位（相当于16个十进制位），大于这个范围的整数，**无法精确表示**，不适合**科学金融**方面的精确计算。
  - 二是大于或等于2的1024次方的数值，**无法表示**，会返回**Infinity**。
- bigInt就是用来解决这个问题的，**只能表示整数**，**没有位数限制**，任何位数的整数都能精确表示。为了与Number类型区别，bigInt必须添加后缀n。

### 为什么0.1+0.2!=0.3

- js中的数字是用64位二进制表示的
  - 其中第1位是符号位；
  - 2到12位，共11位是指数部分；
  - 第13到64位，共52位是小数部分，如果小数部分超过52位，就会丢失精度。
- 0.1用二进制表示时，小数部分是1001无限循环，13次1001就占了52位，第53位是1，0舍1入舍去，最后4位最终会变成1010，这样肯定就比0.1大了。0.2也类似，最终相加实际比0.3大。

### 变量提升和函数提升

- 变量提升：var声明的变量，在声明前就可以访问，此时变量值为undefined。
- 函数提升：用function声明函数，在声明前就可以直接调用。
- 先执行变量提升，再执行函数提升。
- let和const有**临时死区**的特性，必须声明才能使用，否则报错。

### ES6模块与CommonJS模块的区别

- CommonJS模块输出的是一个值的拷贝，加载模块后，在模块内改变值不会影响到输出值；ES6模块输出的是值的引用，模块内的输出值变了，会影响到引用它的地方。
- CommonJS模块是运行时加载，ES6模块是编译时输出接口。

### V8 垃圾回收机制

- V8将内存堆分为两个空间：**新生代**和**老生代**，新生代中的对象存活时间较短，老生代中的对象存活时间较长。
- 在新生代空间中，内存空间又分为**两部分**，f**rom空间和to空间**。一个空间是**使用的**，另一个空间是**空闲的**。新分配的对象会被放入From空间中，当From空间占满时，就会启动Scavenge算法进行垃圾回收。该算法会检查from空间中存活的对象，判断对象是否符合晋升条件，如果符合就晋升成老生代，否则将对象复制到To空间中，如果有失活的对象就会销毁。当复制完成后将from空间和to空间互换，这样垃圾回收就结束了。
- 老生代空间会使用两个算法，**标记清除算法**和**标记压缩算法**。
- **标记清除算法**就是遍历堆中所有对象，将存活对象标记出来，然后对**未标记的对象空间**进行**回收**。
- 但经过标记清除后，会造成堆内存**出现碎片**的情况，当**碎片超过一定限制**后就会启动**标记压缩算法**，将活的对象向一端移动，直到所有对象都移动到一边，然后清理掉不需要的内存。

### 事件循环

- js 中有一个**主线程**，一个**调用栈**，和独立于调用栈的消息队列，可分宏任务队列和微任务队列
- 宏任务：script 代码，setTimeout/setInterval/setImmediate, I/O, UI rendering
- 微任务：process.nextTick, Promise, MutationObserver
- 代码执行过程中，将任务的各自回调函数根据任务类型放入对应的任务队列中
- 主执行栈清空，依次执行微任务队列中的任务，微任务队列清空后，再执行宏任务队列中的下一个任务

### JS异步编程方式

- 回调函数
- Promise
  - Promise是ES6新增的语法，是异步编程的一种解决方案，解决了传统回调函数方式的地狱回调的问题。
  - Promise是一个构造函数，接受一个方法，方法有两个参数，分别是resolve和reject，通过构造函数可以创建Promise实例
  - 一个Promise实例对象有三种状态，初始为pending状态，可以通过resolve和reject函数将状态转变为resolved和rejected状态，状态一旦改变就不能再次改变。
  - promise实例对象还有一个then方法，方法接受一个回调方法，当状态从pending变为resolved或rejected后，就会执行then中的这个回调方法，他的返回值是一个新的promise实例
- Generator
  - Generator是ES6中新增的语法，也是异步编程的解决方案。
  - 声明函数时在函数名前加*号，就可以声明一个Generator函数，函数内使用yield表达式，定义不同的内部状态，执行该函数会返回一个遍历器对象。
  - 这个遍历器对象代表Generator函数的内部指针，每次调用遍历器对象的next方法，会返回一个有value和done两个属性的对象。
  - value属性表示当前内部状态的值，是yield表达式后面那个表达式的值；done属性是一个boolean，表示是否遍历结束
- async/await
  - 是Generator函数的语法糖，Generator函数的执行需要执行器，async函数自带执行器
  - async 声明一个异步函数，其返回值是一个Promise对象，只有在async函数内部异步操作执行完，才会执行then方法指定的回调，内部可使用await
  - await只能在async声明的函数中使用，放在Promise对象前，后面的代码会等到Promise完成并返回结果后才执行。
  - 优势
    - 同步的写法更加优雅，不仅解决了回调地狱问题，还省去了then的链式调用所带来的阅读负担
    - 处理错误的方式更加友好，可以用try/catch方式，而不是Promise的错误捕获方式
    - 调试更加方便

## Vue相关

### 虚拟DOM

- **本质**是用一个原生JS对象去**模拟**一个DOM节点，是对真实DOM的一层**抽象**。

- 为什么要用虚拟DOM？
  - 直接频繁操作DOM不好，表现在
    - JS操作DOM相对比较慢，JS引擎和渲染引擎是相互独立的，双方通信需要成本。
    - 频繁操作DOM会造成浏览器大量回流和重绘，消耗大量性能。
    - 省略手动操作DOM可以提高开发效率
  - 初衷是为了跨平台，nodejs环境中没有DOM，如果想实现服务端渲染（SSR），需要借助VDOM。

### diff算法（snabbdom.js）

- 将**虚拟DOM树同一级**的**新节点数组**与**旧节点数组**进行对比，并用**四个指针**分别指向这**两个数组**的**头尾**。

- 一直循环进行**头尾交叉对比**，直到两个数组中**任一数组**的**头指针超过尾指针** ，具体过程是:
  - 头头对比: 如相同把新节点patch到旧节点，头指针后移，否则继续
  - 尾尾对比: 如相同把新节点patch到旧节点，尾指针前移，否则继续
  - 旧尾新头对比: 如相同，把新节点patch到旧节点，旧尾指针前移，新头指针后移，否则继续
  - 旧头新尾对比: 如相同，把新节点patch到旧节点，新尾指针前移，旧头指针后移，否则继续
  - 利用key对比: 在旧节点数组中寻找新头指针指向的节点的key，这里**分三种**情况，
    - 没有对应的key，那创建新节点
    - 如果有对应key并且是相同的节点，把新节点patch到旧节点
    - 如果有对应key但是不是相同的节点，那也创建新节点

- 循环结束后，两个数组中可能存在没有遍历完的情况
  - 如新数组没遍历完，则添加新数组中漏掉的节点
  - 如旧数组没遍历完，则删除旧数组中漏掉的节点

### MVVM是什么

- 概述
  - MVVM是`Model-View-ViewModel`的缩写，分为三层
  - Model层主要是提供**数据模型**；
  - View层则是的提供**视图模板**，定义**结构布局**，展示**数据状态**，做了数据和事件的**绑定声明**，**指令声明**；
  - ViewModel是**View**和**Model**层的**桥梁**，数据绑定在ViewModel层会自动将数据渲染到页面，双向绑定的视图变化的时候也会通知ViewModel层更新数据。
- 优点
  - **分离**视图和模型，**降低**代码耦合，**提高**视图和逻辑复用
  - **双向绑定DOM**自动更新，开发者不用手动操作DOM
  - 便于**测试**
- 缺点
  - BUG难调试，双向绑定导致BUG**难以定位**错误发生在View层还是Model层。
  - 大型应用维护数据多，ViewModel构建维护成本会增大，Model层的数据长期持有也会大量占用内存。

### Vue的生命周期

- beforeCreate：当前阶段data、methods、computed以及watch上的数据和方法**都不可访问**。
- created：发生在实例创建后，这时候已**完成数据监测**，可**使用和获取**数据，但**无法与DOM交互**。
- beforeMount：发生在DOM挂载前，这时候**虚拟DOM已创建完成**，**即将开始渲染**。
- mounted：发生在DOM挂载后，数据**完成双向绑定**，**可访问DOM**。
- beforeUpdate：发生在响应式数据更新前，这时候虚拟DOM还没有重新渲染，还**可以更改数据**。
- updated：发生在数据更新后，**不能在此更改数据**，可能会导致**死循环**。
- beforeDestroy：发生在组件销毁前，可进行**收尾工作**，比如清除定时器。
- destroyed：发生在组件销毁后，只剩下DOM空壳，**数据绑定**和**监听**都被移除，**子组件**也被销毁。

### Vue的通信方式

1. `props/$emit+v-on`，通过props将数据自上而下传递，通过$emit和v-on向上传递；
2. 通过`EventBus`进行信息的发布订阅，利用vue实例的$emit和$on
3. 使用`vuex`，全局状态管理
4. 使用`$attrs/$listeners`，配置v-bind="$attrs"获取在父中定义的所有属性，配置v-on="$listeners"获取子中发布的所有事件
5. 使用`ref`可在父中访问子实例
6. 使用`$children/$parent`访问实例
7. 使用`provide/inject`，父通过provide提供变量，子通过inject注入变量，不管多深，但数据是非响应式的。
8. `localStorage/sessionStorage`

### computed和watch的区别

- computed是依赖于一个或多个属性，然后改变指定的属性值，有缓存性，只有依赖的属性发生改变才重新计算，常用于格式化数据
- watch是监听一个属性的变化而做一系列操作，比如要调ajax请求。

### Vue如何实现双向绑定的

- 采用**数据劫持**结合**发布订阅**模式，通过**Object.defineProperty()**来**劫持**数据对象各属性的**setter、getter**，在**数据变动**时**发布消息**给订阅者，**触发**相应监听**回调**。
- 具体实现
  - 实现一个数据监听器`Observer`，能够对数据对象各属性进行监听，如有变动获取最新值，通知订阅者；
  - 实现一个指令解析器`Compile`，对每个元素节点的指令进行扫描解析，根据指令模板替换数据，以及绑定相应的更新函数；
  - 实现一个`Watcher`，作为连接`Observer`和`Compile`的桥梁，能够订阅并收到属性变动通知，执行指令绑定的相应回调，从而更新视图；
  - 最后实现一个`MVVM`入口，用来接收数据对象，指定视图模板，调度`Observer`，`Compile`和`Watcher`。

### v-model的原理

- `v-model`本质是`value + input`方法的语法糖。可以通过model属性的`prop`和`event`属性来进行自定义。原生的v-model，会根据标签的不同生成不同的事件和属性。

### Vue事件绑定原理

- 原生事件绑定是通过`addEventListener`绑定给真实元素的，组件事件绑定是通过Vue自定义的`$on`实现的。

### Vue的模版编译原理

- Vue的编译过程就是将`template`转化为`render`函数的过程，主要分三步：
  1. 通过**解析器**，将**模板**转成**抽象语法树**（AST)；
  2. 通过**优化器**，对**AST**进行**静态节点标记**，主要用来做**虚拟DOM的渲染优化**；
  3. 通过**代码生成器**，将**AST**转成**render函数代码字符串**。

### Proxy相对于Object.defineProperty的优势

1. 可以直接监听**对象而非属性**，不用再遍历对象的属性
2. 可以直接监听**数组**的变化
3. 有多达**13**种拦截方法
4. 返回一个**新对象**，可以只操作新对象达到目的
5. 作为**新标准**，受到浏览器厂商重点持续的性能优化

### Vue中是如何检测数组变化

使用了**数据劫持**的方式，将数组操作的**7个方法**进行了**原型链重写**，指向了**自己定义**的数组方法，其实就是先调用了数组原本的方法，然后**添加通知依赖更新**的代码。这样当调用数组api时，就可以检测数组变化。如果数组中**包含**着**引用类型**，还会对数组中的引用类型**再次递归遍历**进行监控。

### Vue的key有什么用

- key是vue中虚拟DOM唯一标识，通过这个key，diff操作可以更准确，更快速。
- diff算法过程中，先会进行新旧节点的首尾交叉对比，当无法匹配的时候会用新节点的key与旧节点的key进行对比，然后查出差异。
- （准确）如果**不加key**，vue会选择**复用节点**，导致旧节点的**状态被保留**下来，产生一系列BUG
- （快速）key是唯一的，查找一个节点**不需要遍历**，因此更快速。

### nextTick的实现原理

在下次 DOM 更新循环结束之后执行延迟回调。nextTick主要使用了微任务，特殊情况会使用宏任务。根据执行环境分别尝试采用

- `Promise`(微)
- `MutationObserver`（微）
- `setImmediate`（宏）
- `MessageChannel`（宏）
- `如果以上都不行则采用setTimeout`（宏）

它定义了一个异步方法，多次调用nextTick会将方法存入队列中，通过这个异步方法清空当前队列。

### keep-alive的作用

- `keep-alive`可以实现组件**缓存**，当组件切换时**不会**对当前组件进行**卸载**。
- 常用的两个属性`include/exclude`，允许设置只对哪些组件进行缓存。
- 两个生命周期钩子`activated/deactivated`，分别在组件**激活**和**休眠**时触发。

### Vuex的原理

### Vue-Router的原理



## 手写与算法

### 实现类的继承

### 实现new

### 实现Object.create

### 实现instanceOf

### 实现call、apply和bind

### 实现防抖节流

- 防抖和节流都是限制事件触发回调在一段时间以后才能再次执行的方式；
- 区别在于防抖是从上一次触发事件的时间开始计时，而节流是从上一次执行回调方法的时间开始计时。

### 实现deepClone

### 实现Promise

### 实现事件订阅发布

### 实现类型判断方法的封装 

### 排序算法

## 浏览器、HTTP和前端安全

### 从浏览器地址栏输入url到显示页面的步骤

1. 在浏览器地址栏输入URL
2. 浏览器查看缓存，如果请求资源在缓存中并且新鲜，跳转到转码步骤
   1. 如果资源未缓存，发起新请求
   2. 如果已缓存，检验是否足够新鲜，足够新鲜直接提供给客户端，否则与服务器进行验证。
   3. 检验新鲜通常有两个HTTP头进行控制`Expires`和`Cache-Control`：
      - HTTP1.0提供Expires，值为一个绝对时间表示缓存新鲜日期
      - HTTP1.1增加了Cache-Control: max-age=,值为以秒为单位的最大新鲜时间
3. 浏览器**解析URL**获取协议，主机，端口，path
4. 浏览器**组装一个HTTP（GET）请求报文**
5. 浏览器获取主机ip地址，过程如下：
   1. 浏览器缓存
   2. 本机缓存
   3. hosts文件
   4. 路由器缓存
   5. ISP DNS缓存
   6. DNS递归查询（可能存在负载均衡导致每次IP不一样）
6. 打开一个socket与目标IP地址端口建立TCP连接，进行三次握手
7. TCP链接建立后**发送HTTP请求**
8. 服务器接受请求并解析，将请求转发到服务程序，如虚拟主机使用HTTP Host头部判断请求的服务程序
9. 服务器检查**HTTP请求头是否包含缓存验证信息**如果验证缓存新鲜，返回**304**等对应状态码
10. 处理程序读取完整请求并准备HTTP响应，可能需要查询数据库等操作
11. 服务器将**响应报文通过TCP连接发送回浏览器**
12. 浏览器接收HTTP响应，然后根据情况选择关闭TCP连接或者保留重用，关闭TCP连接的四次握手
13. 浏览器检查响应状态吗：是否为1XX，3XX， 4XX， 5XX，这些情况处理与2XX不同
14. 如果资源可缓存，**进行缓存**
15. 对响应进行**解码**（例如gzip压缩）
16. 根据资源类型决定如何处理（假设资源为HTML文档）
17. 进入浏览器的渲染过程。
18. js解析如下：
    1. 浏览器创建Document对象并解析HTML，将解析到的元素和文本节点添加到文档中，此时**document.readystate为loading**
    2. HTML解析器遇到**没有`async`和`defer`的`script`时**，将他们添加到文档中，然后执行行内或外部脚本。这些脚本会同步执行，并且在脚本下载和执行时解析器会暂停。这样就可以用`document.write()`把文本插入到输入流中。**同步脚本经常简单定义函数和注册事件处理程序，他们可以遍历和操作script和他们之前的文档内容**
    3. 当解析器遇到设置了**`async`**属性的script时，开始下载脚本并继续解析文档。脚本会在它**下载完成后尽快执行**，但是**解析器不会停下来等它下载**。异步脚本**禁止使用`document.write()`**，它们可以访问自己script和之前的文档元素
    4. 当文档完成解析，`document.readState`变成interactive
    5. 所有`defer`脚本会**按照在文档出现的顺序执行**，延迟脚本**能访问完整文档树**，禁止使用`document.write()`
    6. 浏览器**在Document对象上触发`DOMContentLoaded`事件**
    7. 此时文档完全解析完成，浏览器可能还在等待如图片等内容加载，等这些**内容完成载入并且所有异步脚本完成载入和执行**，`document.readState`变为complete，window触发load事件
19. **显示页面**（HTML解析过程中会逐步显示页面）

> 简版

1. 首先做 DNS 查询，如果这一步做了智能 DNS 解析的话，会提供访问速度最快的 IP 地址回来
2. 接下来是 TCP 握手，应用层会下发数据给传输层，这里 TCP 协议会指明两端的端口号，然后下发给网络层。网络层中的 IP 协议会确定 IP 地址，并且指示了数据传输中如何跳转路由器。然后包会再被封装到数据链路层的数据帧结构中，最后就是物理层面的传输了
3. TCP 握手结束后会进行 TLS 握手，然后就开始正式的传输数据
4. 数据在进入服务端之前，可能还会先经过负责负载均衡的服务器，它的作用就是将请求合理的分发到多台服务器上，这时假设服务端会响应一个 HTML 文件
5. 首先浏览器会判断状态码是什么，如果是 200 那就继续解析，如果 400 或 500 的话就会报错，如果 300 的话会进行重定向，这里会有个重定向计数器，避免过多次的重定向，超过次数也会报错
6. 浏览器开始解析文件，如果是 gzip 格式的话会先解压一下，然后通过文件的编码格式知道该如何去解码文件
7. 文件解码成功后会正式开始渲染流程，先会根据 HTML 构建 DOM 树，有 CSS 的话会去构建 CSSOM 树。如果遇到 `script` 标签的话，会判断是否存在 `async` 或者 `defer` ，前者会并行进行下载并执行 JS，后者会先下载文件，然后等待 HTML 解析完成后顺序执行，如果以上都没有，就会阻塞住渲染流程直到 JS 执行完毕。遇到文件下载的会去下载文件，这里如果使用 HTTP 2.0 协议的话会极大的提高多图的下载效率。
8. 初始的 HTML 被完全加载和解析后会触发 `DOMContentLoaded` 事件
9. CSSOM 树和 DOM 树构建完成后会开始生成 Render 树，这一步就是确定页面元素的布局、样式等等诸多方面的东西
10. 在生成 Render 树的过程中，浏览器就开始调用 GPU 绘制，合成图层，将内容显示在屏幕上了

### 浏览器渲染过程

1. 浏览器获取HTML文件，然后解析，形成**DOM Tree**
2. 与此同时，进行CSS解析，生成CSS对象模型（**CSSOM Tree**）
3. 接着将Dom Tree与CSSOM Tree**合成为Render Tree**
4. 接着进入布局阶段（**Layout**)阶段，为每个节点分配一个应出现在屏幕上的确切坐标
5. 随后调用**GPU进行绘制**，遍历Render Tree的节点，并将元素呈现出来

### onload、DOMContentLoaded事件的触发顺序

1. 当onload事件触发时，页面上所有的DOM，样式表，脚本，图片等都已经加载好了。
2. 当DOMContentLoaded事件触发时，只有DOM加载完成。

### DOM Tree是如何构建的

1. 转码：**浏览器**将接收到的**二进制数据**按照**指定编码格式**转化为**HTML字符串**
2. 生成Tokens：浏览器**渲染引擎**将HTML字符串解析成**Tokens**
3. 构建Nodes：对Node**添加特定属性**，通过**指针定**Node的父、子、兄弟**关系**和**所属treeScope**
4. 生成Dom Tree：通过node包含的**指针**确定的**关系**构建出**DOM Tree**

### 浏览器回流和重绘的区别

- 重排：部分**渲染树**（或者整个渲染树）需要**重新分析**并且**节点尺寸****需要重新计算**，表现为重新生成布局，重新排列元素
- 重绘：节点的**几何属性**发生改变，表现为某些元素的**外观被改变**。

### 什么是同源策略，如何实现跨域

- 同源是指“协议+域名+端口”三者相同，两个不同域名指向同一IP也属于非同源。
- 同源策略是一种约定，它是浏览器的安全基石，如果缺少了同源策略的限制，浏览器很容易遭受XSS、CSRF等攻击。
- 有三个标签不受同源策略限制：
  - img标签
  - link标签
  - script标签
- 如何实现跨域
  - JSONP
  - CORS
  - 服务器代理

### 实现即时通讯的方式

1. 短轮询
2. comet技术
3. Server Send Event
4. WebSocket

### 什么是HTTP

HTTP是超文本传输协议（Hyper Text Transfer Protocol）是一种通信协议，它允许将超文本标记语言（HTML)文档从WEB服务器传送到客户端的浏览器。HTTP协议是构建在TCP/IP协议之上的，是TCP/IP协议的一个子集。

### HTTP有哪些方法

1. GET， 获取资源
2. POST ，发送数据
3. OPTIONS， 查看资源支持什么方法请求
4. HEAD， 获取请求资源的头部信息，如在下载大文件前先获取大小，再决定是否下载
5. PUT， 新增或更新资源
6. DELETE，删除资源
7. PATCH，局部修改资源
8. CONNECT， 把请求连接转换成透明的TCP/IP通道
9. TRACE， 用来激发一个远程的应用层的请求消息回路

### GET/POST POST/PUT PUT/PATCH的区别

- GET/POST区别：
  - 数据传输方式不同
  - 安全性不同
  - 数据类型不同
  - 特性不同
- PUT/POST区别：PUT是更新资源PUT幂等，POST是提交资源POST非幂等
- PUT/PATCH的区别：都是更新资源，PATCH可对资源进行局部更新

### HTTP报文

- 请求报文：
  - 请求行，包括请求方法，URL和HTTP协议版本号
  - 请求头，由键值对组成，每行一对，冒号分隔
  - 空行
  - 请求体，post put等方法携带的数据
- 响应报文
  - 响应行，包括HTTP协议版本，状态码和状态码短语
  - 响应头，由键值对组成，每行一对，冒号分隔
  - 空行
  - 响应体，服务器返回的数据

### HTTP首部

- 通用首部
- 请求首部
- 响应首部
- 实体首部
- 常见

### HTTP的keep-alive是干什么的

在早期HTTP/1.0版本，每一次HTTP请求都要建立一个连接，创建连接需要消耗资源和时间，为了减少资源消耗缩短时间，就需要重用连接。在HTTP请求头中加入Connection: keep-alive就可以告诉对方这个请求响应完成后不要关闭连接，下次还用这个请求继续交流。
优点：

1. 由于打开的连接少了，CPU和内存的使用会减少

2. 允许请求和应答的HTTP管线化
3. 降低拥塞控制
4. 减少后续请求的延迟
5. 报告错误无需关闭TCP连接

### HTTP状态码

- 1xx：信息状态码
  - 101 协议变更
- 2xx：成功状态码
  - 200 OK，表示请求成功
  - 201 Created， 请求已被实现，而且有一个新的资源已经依据请求需求而建立
  - 202 Accepted，请求被接受，但还没执行，不保证完成请求
  - 204 No content，请求成功，但响应报文不含任何主体部分
  - 206 Partial Content， 进行范围请求
- 3xx：重定向
  - 301 moved permanently，永久性重定义
  - 302 found, 临时性重定义
  - 303 see other，表示资源存在另一个URL，应使用get方法定向获取资源
  - 304 not modified， 一般是命中协商缓存时使用
- 4xx：客户端错误
  - 400 bad request，请求报文语法错误
  - 401 unauthorized，需要认证信息
  - 403 forbidden，资源禁止访问
  - 404 not found，资源不存在
- 5xx：服务端错误
  - 500 internal server error，服务端内部错误
  - 502 bad gateway，网关或代理服务器从上游服务器获取的响应无效
  - 503 service unavailable， 服务器处理超负载或正在维护

### 说说HTTPS

- HTTP协议数据都是明文进行传输的，缺乏安全性，而HTTPS就是为了解决HTTP的不安全的问题。
- HTTPS如何保证安全？
  - 先说一下对称加密和非对称加密。
  - 对称加密是使用同一个密钥进行加解密。在通信过程中，先把密钥发送给对方，把加密后内容发给对方，然后对方使用密钥解密。
  - 非对称加密则是有一个密钥对，公钥和私钥，公钥加密私钥解密，或者私钥加密公钥解密。在通信过程中，把自己的公钥发送给对方，对方使用公钥加密后把加密内容返回，然后用自己的私钥解密。
  - HTTPS则是结合这两种加密方式，将对称加密的密钥使用非对称加密的公钥加密，然后发送出去，接收方使用私钥解密，得到对称加密的密钥，然后双方可以使用对称加密进行沟通。
  - 但这样仍存在问题，即中间人可以在一开始发送公钥的时候，把公钥换成自己的公钥，这样就可以用自己的私钥来解密。
  - 这时就需要一个安全的第三方颁发的证书，证明发送方的身份，防止被中间人攻击。
  - 服务器会把带有自己公钥的这个第三方颁发的证书发送给客户端，客户端可以通过证书上的信息对发送方的身份进行验证，如果验证通过，说明这个公钥是可靠安全的。
  - 具体验证方式：证书颁发机构会先用证书指定的HASH算法对证书内容进行HASH得到摘要，再用机构自己的私钥加密，组成数字签名，然后得到签署了数字签名和服务器公钥的证书，服务器将这个证书发给客户端，客户端使用机构的公钥对数字签名进行解密得到摘要，然后使用证书上的HASH算法对内容进行HASH也得到摘要，对比两个摘要就知道中间是否被篡改。

### 说说HTTP2

相对于HTTP1有以下优势 ：

1. 二进制传输：之前的HTTP1.0是通过**文本的方式**传输数据，2.0采用**二进制格式**编码进行传输，速度更快。
2. 多路复用：一个TCP连接中可以**存在多个请求**，对端可以通过**帧中的标识**知道属于哪个请求，解决了**队头阻塞**的问题，提高传输效率。
3. 头部压缩：2.0对传输的header进行了**压缩**，并在两端维护了**索引表**，记录出现过的header，后面如果header的键值没变，就可以只传输键名。
4. 服务端推送：服务端可以在客户端的某个请求后，主动推送其它资源。

### 说说HTTP缓存

良好的缓存策略可以**降低资源的重复加载**，**提高网页的整体加载速度**。

缓存策略可分为强缓存和协商缓存：

- **强缓存**，可以通过两个响应头来实现
  - Expires，它是HTTP/1.0的规范，值是一个GMT格式的时间字符串，表示资源的有效期，当再次请求该资源时，会去判断当前时间是否超过有效期，如果没有超过就会命中强缓存，返回状态码200，使用缓存资源，如果超过了说明缓存可能已经过期了，将使用协商缓存。
  - Cache-Control: 它是HTTP/1.1的规范，优先级高于Expires，它可设置max-age的值，这个值的单位是秒，表示在N秒内再次请求资源会使用强缓存，否则会使用协商缓存。
- **协商缓存**，会去请求服务器验证当前缓存是否新鲜，它也有两种实现方式
  - Last-Modified（值为资源最后更新时间，随服务器response返回）
  - If-Modified-Since（通过比较两个时间来判断资源在两次请求期间是否有过修改，如果没有修改，则命中协商缓存）
  - ETag（表示资源内容的唯一标识，随服务器response返回）
  - If-None-Match（服务器通过比较请求头部的If-None-Match与当前资源的ETag是否一致来判断资源是否在两次请求之间有过修改，如果没有修改，则命中协商缓存）

### 说说TCP和UDP

> TCP是面向连接的，1对1通信，传输可靠，有序，可进行拥塞控制，但传输速度相对慢，量级较低，头部占20-60个字节

> UDP是无连接的，能提供单播，多播，广播的功能，传输不可靠，无序，不能进行拥塞控制，易丢包，但传输速度快，量级较高，头部大小仅占8字节。

- UDP，是一个面向报文的协议，UDP只是报文的搬运工，不会对报文进行任何拆分和拼接操作。
  - 传输过程：
    - 在发送端，应用层将数据传递给传输层的UDP 协议，UDP只会给数据增加一个UDP头标识一下是UDP协议，然后就传递给网络层
    - 在接收端，网络层将数据传递给传输层，UDP只去除IP报文头就传递给应用层，不会进行任何拼接操。
  - 特点：
    - UDP是无连接的，通信不需要建立和断开连接
    - UDP是不可靠的，协议收到什么数据就传递什么数据，不会备份数据，也不关心对方能不能收到
    - UDP没有拥塞控制，一直会以恒定的速度发送数据，即使网络条件不好，也不会对发送速率进行调整，这种情况下可能会导致丢包，但优点也很明显，在某些实时性要求高的场景，比如电话会议就需要使用UDP而不是TCP
  - 传输方式：UDP不止支持一对一的传输，同样支持一对多，多对多，多对一的方式，提供单播，多播、广播的功能。
- TCP是传输层另一个重要的协议：
  - 提供一种面向连接、可靠的字节流服务
  - 在一个TCP，仅有两方进行通信
  - TCP使用校验和、确认和重传机制来保证传输的可靠性
  - TCP给数据分节进行排序，并使用**累积确认**来保证数据的顺序不变和非重复
  - TCP使用滑动窗口机制来实现流量控制，通过动态改变窗口大小进行拥塞控制

### 说说TCP的三次握手和四次挥手

- 三次握手
  - 第一次握手，客户端向服务端发送一个SYN标志位为1，发送序号为X的包，客户端进入SYN_SENT状态
  - 第二次握手，服务端接收到客户端的包后，发回一个SYN标志位和ACK标志位均为1，发送序列为Y，确认序号为X+1的包，服务端进入SYN_REVD状态
  - 第三次握手，客户端接收到客户端的包后，再次发送一个ACK标志位为1，确认序号为Y+1的确认包，双方进入established状态
- 四次挥手
  - 第一次挥手：假设客户端想关闭连接，客户端发送一个FIN标志位为1，发送序号为X的包，表示自己没有数据可以发送，但可以接受数据，客户端进入FIN_WAIT_1状态
  - 第二次挥手：服务端接收后，发送一个ACK标志位为1，确认序号为X+1的确认包，表示自己接受了客户端的关闭连接请求，但还没有准备好关闭连接，服务端进行CLOSE_WAIT状态，客户端接收到确认包后，进行FIN_WAIT_2状态，等待服务器关闭连接
  - 第三次挥手：服务端准备好关闭连接时，向客户端发送一个FIN标志为1，发送序号为Y的包，服务器进入LAST_ACK状态，等待客户端的最后一次确认
  - 第四次挥手：客户端接收到服务端的关闭请求，会向服务器发送一个ACK为1，确认序号为Y+1的确认包，并进入TIME_WAIT状态，等待可能出现的要求重传的ACK包，服务器端接收到这个包后，会关闭连接，进行CLOSED状态，客户端会等待两个最大段生命周期的时间，没有收到ACK包，就认为服务器正常关闭连接，于是自己也关闭连接，进入CLOSED状态。

### WEBSOCKET握手过程

Websocket是一个全新、独立的协议，基于TCP协议，与http协议兼容，作为H5的一部分，作用就是在服务端和客户端之间建立实时的双向通信。

优点：实时双向通信，性能好，延迟低

缺点：独立于http协议，需要额外的项目改造，使用复杂度高，无法兼容低版本浏览器

协议包括：

- 握手
  - 发送握手请求，是一个HTTP GET请求，协议版本至少是1.1，请求头比普通请求多了一些字段
    - Connection：值为Upgrade，告诉服务器当前请求连接是升级的
    - Upgrade：值为websocket，告诉服务器这个HTTP连接是升级的WS连接
    - Sec-Websocket-Version：值必须是13
    - Sec-Websocket-Key：发送一个key给服务端，服务端返回一个校验过的字符串给客户端，验证通过后才正式建立连接
    - Sec-Websocket-Protocol：表示客户端可以接受的子协议类，服务端要返回其中一个子协议。
  - 返回握手应答，响应行中的状态码为101，表示发生了协议变换，响应头中包含
    - Upgrade和Connection，告诉客户端同意升级并使用websocket协议
    - Sec-WebSocket-Accept，服务端将加密处理后的握手Key通过这个字段返回，表示服务器同意建立连接
    - Sec-WebSocket-Procotol，服务器选择一个应用层协议
- 数据传输

### 前端安全问题

1. XSS
2. CSRF

## 前端工程化和优化

### webpack的构建流程

### webpack和gulp的区别

### loader和plugin的区别

### 常用的loader

### 常用的plugin

### 如何编写loader和plugin

### webpack的热更新是怎么实现的

### 如何用webpack来优化前端性能

### 如何提高webpack的打包速度和构建速度

### 怎么配置单页应用和多页应用

### babel的原理

### 如何写一个Babel插件

### git工作流是怎样的

### rebase与merge的区别

### git reset\git revert\git checkout的区别

### 首屏优化

### 怎么做前端优化？

1. 网页内容
   - 减少HTTP请求次数
   - 减少DNS查询次数
   - 避免页面跳转
   - AJAX缓存
   - 懒加载
   - 提前加载
   - 减少DOM元素数量
   - 根据域名划分内容
   - 减少iframe数量
2. 服务器
   - 使用CDN
   - 添加Expires或者Cache Control报文头
   - Gzip压缩文件
   - 配置Etags
   - 尽早flush输出
   - 使用ajax
   - 避免空的图片src
3. Cookie
   - 减少Cookie大小
   - 页面内容使用无Cookie域名
4. CSS
   - 样式表置顶
   - 避免CSS表达式
   - 代替@import
   - 避免使用Filters
5. JS
   - 脚本置底
   - 使用外部js和CSS文件
   - 精简JS和CSS
   - 去除重复脚本
   - 减少DOM操作
   - 使用事件代理
6. 图片
   - 优化图片
   - 使用雪碧图
   - 不要在HTML中缩放图片
   - 使用小且可缓存的ico