---
sidebar: auto
---

# 前端面试题

## HTML

### SEO（搜索引擎优化，Search Engine Optimization）

前端需注意的SEO有：

- 合理使用`title`、`description`、`keywords`：这三项的权重逐个减小；
- 语义化的`HTML`代码：让搜索引擎更容易理解网页；
- 重要的`HTML`代码要放在最前：搜索引擎抓取`HTML`顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容优先被抓取；
- 重要内容不要用`js`输出并且少用`iframe`：爬虫不会执行`js`，也不会抓取`iframe`中的内容；
- 非装饰性图片必须加`alt`属性；
- 提高网站**速度**：网站速度是搜索引擎排序的一个重要指标

### doctype的作用

- DOCTYPE是HTML页面的标准声明，必须声明在HTML文档第一行。它的作用是告知浏览器解析器用什么文档标准来解析页面。
- 有两种解析模式：标准模式和怪异模式。
  - 标准模式是使用W3C的标准解析渲染页面。
  - 怪异模式是用浏览器自己的标准解析渲染页面，不同浏览器看到的渲染结果不同，不声明DOCTYPE就会使用怪异模式。

### HTML、XML和XHTML的区别

- HTML是超文本标记语言，在HTML4.0前先有实现后有标准，导致HTML非常混乱和松散
- XML是可扩展标记语言，主要用来存储数据，可以扩展。
- XHTML是可扩展超文本标记语言，基于HTML和XML，W3C用它来解决HTML的混乱问题，并基于此诞生了HTML5，在开头加了DOCTYPE声明，开启标准模式。

### HTML5新特性

1. H5文档声明类型**仅有一型**，即`<!DOCTYPE HTML>`，**不再基于SGML**，不需要引用**DTD**
2. **新元素标签**，如**语义化标签**header, footer, section, nav, aside，**多媒体标签**video, audio, canvas
3. **input元素**添加了**新的类型**，如date, time, email等。
4. 添加了**新的技术**，如`WebWorker`、`Websocket`、`Geolocation`
5. **新增属性**和指定了**全域属性**, 比如meta标签的charset属性, script标签的defer和async属性，全域属性包括id, tabindex, repeat。
6. H5**移除**了一些元素，如big, center, font, frame等等

### 什么是HTML语义化

HTML语义化就是**使用适当语义**的HTML标签，让页面具有**良好的结构和含义**。

它的好处主要有两点：

	1. 对开发者友好，增强代码可读性，便于团队开发和维护
 	2. 对机器友好，适合搜索引擎的爬虫爬取有效信息，支持读屏软件，根据文档生成目录等。

### 常用meta标签有哪些

meta标签用来**描述HTML文档元信息**，例如**作者**，**日期时间**，**关键字**，**自动刷新的时间间隔**等。

常用的meta：

1. 比如`charset`，设置**文档编码形式**
2. `http-equiv`, 设置**http的文件头**，如设置http缓存过期时间
3. `viewport`，常用于**移动开发**，可以**控制视口的大小和比例**等。

### src和href的区别

- src
  - 指向**外部资源的位置**；
  - 会将指向的内容**下载并会嵌入**到标签所在位置，如js，图片，多媒体，frame等元素；
  - 当浏览器解析到这个元素时，**会暂停其它资源下载和处理**，直到资源加载、编译、执行完毕。（不一定准确，chrome中多个js资源的下载是并行的）
- href
  - 指向**网络资源所在位置**
  - 用来**建立**当前元素与文档间的**链接**
  - 当浏览器识别到它指向的文件时，会并行下载资源，**不会停止对当前文档的处理**。

### img标签的title和alt有什么区别

- `title`是当鼠标悬浮在元素上的时候显示
- `alt`是的特有属性，是图片内容的等价描述，当图片无法加载时显示、可用于读屏器阅读图片，提高图片的访问性，非装饰性图片都必须设置有意义的值，有利于SEO。

### Canvas和SVG的区别

- `svg`绘制出来的每一个图形的元素都是独立的`DOM`节点，而`canvas`输出的是一整幅画布。
- `svg`输出的图形是矢量图形，能修改参数自由放大缩小，不会失真。而`canvas`输出的画布就像一张图片，放大时会失真。

### script标签的defer和async的区别

- 默认遇到script标签会停止HTML解析，等待脚本加载完毕后，再继续解析文档，也就是会阻塞文档解析。
- 加async属性，脚本会异步加载，加载完后立即执行，阻塞HTML解析，而且不能保证脚本执行顺序
- 加defer属性，脚本也会异步加载，但不会立即执行，会等到HTML解析完成后再执行，能保证脚本执行顺序。

### 前端存储方式

有五种存储方式，分别是cookie, localStorage, sessionStorage, indexDB, webSQL。

1. cookie的优点就是兼容性好，使用方便。缺点是大小只有4KB，请求头自带cookie浪费流量，每个domain的cookie个数有限制。
2. localStorage和sessionStorage差不多，一个是永久存储，除非手动删除，一个是会话级存储，即页面关闭数据就没了。
3. indexDB是H5的数据库储存方案，用key-value进行存储，用JS操作方便
4. webSQL已被W3C废弃，属于关系型数据库，用SQL操作，较为繁琐，用得较少。

## CSS

### CSS选择器优先级

### link和@import的区别

### CSS隐藏元素的方式和区别

### CSS有几种定位方式

### 盒模型

### 伪元素和伪类

### BFC

### 媒体查询

### z-index和层叠上下文

## Javascript

### 原型和原型链

1. 几乎所有**函数**都有一个prototype属性，它会指向这个函数创建的**实例对象**的原型
2. **实例对象**也会有一个`__proto__`属性指向自己的隐式原型。(`Person.prototype === person.__proto__`)
3. 原型是个对象，它有一个 `constructor` 属性指向构造函数本身
4. 原型有以下特点：
   - 原型对象上添加属性，所有实例都会共享这些属性
   - 在对象上查找自身没有的属性时，会从对象的原型上找，找不到就找原型的原型，一直找到 Object.prototype，找不到就返回undefined
5. 原型链就是查找对象属性时所形成的链式结构。

### 作用域和作用域链

1. 代码**定义变量**的区域，它规定了**如何查找**变量，确定当前执行代码对变量的**访问权限**。
2. 根据代码所在的位置可分为：全局、函数和 eval 作用域。
3. JS 是**静态作用域**，函数的作用域在函数创建的时候就已确定。
4. 作用域可**嵌套**，在查找变量时，先从当前作用域中查找，找不到就在外层的作用域中找，一直找到全局作用域，找不到就报错。
5. **逐层嵌套**的作用域形成的链式结构就是作用域链。

### 闭包

1.  函数嵌套，内部函数引用了外部函数的变量，这样就能产生闭包；
2.  闭包有两种理解：
    - 这个内部函数就是闭包
    - 闭包是包含引用变量的对象，谷歌浏览器debugger时可以看到这个closure对象。
3.  闭包的作用
    - 延长了引用变量的生命周期
    - 让外部可以使用函数内部的变量，突破了作用域的限制
4.  闭包的缺点
    - 变量未释放会占用内存
    - 滥用闭包会导致内存泄漏

### this 的指向

1. 默认情况，非严格模式，this 指向全局对象
2. 在函数中 this 一般指向调用该函数的对象
3. 使用 call,apply,bind 方法可显式指定 this 的指向
4. 使用 new 调用构造函数，函数中的 this 指向新创建的实例对象
5. 箭头函数没有自己的 this，函数中的 this 指向箭头函数所在的上下文中的 this

### js 执行机制

一段JS代码的运行可分为两个阶段：

- 编译阶段，先进行分词/词法分析，再进行解析/语法分析，最后进行预编译
- 执行阶段，js代码并非简单的一行行解释执行的，而是将js代码分为一块块的可执行代码块进行执行，可分为三类，分别是
  - 全局代码块
  - 函数代码块
  - eval代码块

JS引擎由两个主要部分组成：

- 内存堆：是内存分配地址的地方
- 调用栈：是代码执行地方

在代码块执行前会先创建执行上下文，三种代码块会对应三种执行上下文，分别是全局、函数和eval执行上下文。

- 全局执行上下文，任何不在函数内部的代码都在全局上下文中，一个程序只有一个全局上下文，它会执行两件事：
  - 创建一个全局的window对象
  - 设置this的值等于这个全局对象
- 函数执行上下文，每当一个函数被调用时，都会为这个函数创建一个新的执行上下文。
- 在执行eval内部的代码时也会创建它自己的执行上下文。

> 在js引擎首次读取代码时，会创建一个全局执行上下文并将其推入当前的执行栈。每当发生一个函数调用，引擎都会为该函数创建一个新的执行上下文并将其推到当前执行栈顶端。引擎会运行执行上下文栈顶端的函数，当此函数运行完成后，其对应的上下文将会从执行栈中弹出。最终执行栈中的上下文会被清空，这时所有代码执行完毕。

执行上下文的创建可分为两个阶段：

- 创建阶段，主要做一些准备工作
- 执行阶段，主要工作就是给变量赋值

创建阶段做的准备工作包括三点：

- 决定this的指向
- 创建词法环境
- 创建变量环境

词法环境包括两个部分，环境记录器和外部环境的引用

- 环境记录器是存储变量和函数声明的实际位置
- 外部环境的引用是指它可以访问其父级词法环境，也就是作用域。

词法环境分三大类：

- 全局环境，全局环境的外部引用是null，它拥有全局对象，比如window对象，还有用户定义的全局变量，并且this值指向全局对象。
- 模块环境，包含模块顶级声明的绑定以及模块显式导入的绑定，模块环境的外部引用是全局环境。
- 函数环境，函数内部用户定义的变量存储在环境记录器中，外部引用既可以是其它函数的内部词法环境，也可以是全局环境

变量环境也是一个词法环境，不同的是词法环境用来存储函数声明和变量（let和const)的绑定，而变量环境只用来存储var变量绑定。

### null 与 undefined 的区别

- `undefined`表示变量**声明了，未赋值**。
- `null`表示**赋值了，值为空**，将变量赋值为null可用来**主动释放**对象的引用。

### == 和 === 的区别

- === 判断类型和值是否相同，对象类型比较的是内存地址值。
- 用==判断时，如类型相同，会去使用===判断，如类型不同会做隐式类型转换，具体判断流程如下：
  - 判断是否对比` null `和 `undefined`，是就返回 true
  - 判断是否对比 `string `和 `number`，是就将 string 转成 number 再比较
  - 判断其中一方是否为` boolean`，是就将 boolean 转成 number 再比较
  - 判断其中一方是否为 `object`，且另一方为 string，number，symbol，是就把 object 转成原始类型。

### 为什么会有bigint提案

- js所有数字都保存成64位浮点数，这给数值的表示带来两大限制。
  - 一是数值的精度只能到53个二进制位（相当于16个十进制位），大于这个范围的整数，**无法精确表示**，不适合**科学金融**方面的精确计算。
  - 二是大于或等于2的1024次方的数值，**无法表示**，会返回**Infinity**。
- bigInt就是用来解决这个问题的，**只能表示整数**，**没有位数限制**，任何位数的整数都能精确表示。为了与Number类型区别，bigInt必须添加后缀n。

### 为什么0.1+0.2!=0.3

- js中的数字是用64位二进制表示的
  - 其中第1位是符号位；
  - 2到12位，共11位是指数部分；
  - 第13到64位，共52位是小数部分，如果小数部分超过52位，就会丢失精度。
- 0.1用二进制表示时，小数部分是1001无限循环，13次1001就占了52位，第53位是1，0舍1入舍去，最后4位最终会变成1010，这样肯定就比0.1大了。0.2也类似，最终相加实际比0.3大。

### 变量提升和函数提升

- 变量提升：var声明的变量，在声明前就可以访问，此时变量值为undefined。
- 函数提升：用function声明函数，在声明前就可以直接调用。
- 先执行变量提升，再执行函数提升。
- let和const有**临时死区**的特性，必须声明才能使用，否则报错。

### ES6模块与CommonJS模块的区别

- CommonJS模块输出的是一个值的拷贝，加载模块后，在模块内改变值不会影响到输出值；ES6模块输出的是值的引用，模块内的输出值变了，会影响到引用它的地方。
- CommonJS模块是运行时加载，ES6模块是编译时输出接口。

### V8 垃圾回收机制

- V8将内存堆分为两个空间：**新生代**和**老生代**，新生代中的对象存活时间较短，老生代中的对象存活时间较长。
- 在新生代空间中，内存空间又分为**两部分**，f**rom空间和to空间**。一个空间是**使用的**，另一个空间是**空闲的**。新分配的对象会被放入From空间中，当From空间占满时，就会启动Scavenge算法进行垃圾回收。该算法会检查from空间中存活的对象，判断对象是否符合晋升条件，如果符合就晋升成老生代，否则将对象复制到To空间中，如果有失活的对象就会销毁。当复制完成后将from空间和to空间互换，这样垃圾回收就结束了。
- 老生代空间会使用两个算法，**标记清除算法**和**标记压缩算法**。
- **标记清除算法**就是遍历堆中所有对象，将存活对象标记出来，然后对**未标记的对象空间**进行**回收**。
- 但经过标记清除后，会造成堆内存**出现碎片**的情况，当**碎片超过一定限制**后就会启动**标记压缩算法**，将活的对象向一端移动，直到所有对象都移动到一边，然后清理掉不需要的内存。

### 事件循环

- js 中有一个**主线程**，一个**调用栈**，和独立于调用栈的消息队列，可分宏任务队列和微任务队列
- 宏任务：script 代码，setTimeout/setInterval/setImmediate, I/O, UI rendering
- 微任务：process.nextTick, Promise, MutationObserver
- 代码执行过程中，将任务的各自回调函数根据任务类型放入对应的任务队列中
- 主执行栈清空，依次执行微任务队列中的任务，微任务队列清空后，再执行宏任务队列中的下一个任务

### JS异步方式

- 回调函数
- promise
- generator
- async/await
  - 是Generator函数的语法糖，建立在Promise上
  - async 声明一个异步函数，其返回值是一个Promise对象，只有在async函数内部异步操作执行完，才会执行then方法指定的回调，内部可使用await
  - await只能在async声明的函数中使用，放在Promise对象前，后面的代码会等到Promise完成并返回结果后才执行。
  - 优势
    - 同步的写法更加优雅，不仅解决了回调地狱问题，还省去了then的链式调用所带来的阅读负担
    - 处理错误的方式更加友好，可以用try/catch方式，而不是Promise的错误捕获方式
    - 调试更加方便

## Vue相关

### 虚拟DOM

- **本质**是用一个原生JS对象去**模拟**一个DOM节点，是对真实DOM的一层**抽象**。

- 为什么要用虚拟DOM？
  - 直接频繁操作DOM不好，表现在
    - JS操作DOM相对比较慢，JS引擎和渲染引擎是相互独立的，双方通信需要成本。
    - 频繁操作DOM会造成浏览器大量回流和重绘，消耗大量性能。
    - 省略手动操作DOM可以提高开发效率
  - 初衷是为了跨平台，nodejs环境中没有DOM，如果想实现服务端渲染（SSR），需要借助VDOM。

### diff算法（snabbdom.js）

- 将**虚拟DOM树同一级**的**新节点数组**与**旧节点数组**进行对比，并用**四个指针**分别指向这**两个数组**的**头尾**。

- 一直循环进行**头尾交叉对比**，直到两个数组中**任一数组**的**头指针超过尾指针** ，具体过程是:
  - 头头对比: 如相同把新节点patch到旧节点，头指针后移，否则继续
  - 尾尾对比: 如相同把新节点patch到旧节点，尾指针前移，否则继续
  - 旧尾新头对比: 如相同，把新节点patch到旧节点，旧尾指针前移，新头指针后移，否则继续
  - 旧头新尾对比: 如相同，把新节点patch到旧节点，新尾指针前移，旧头指针后移，否则继续
  - 利用key对比: 在旧节点数组中寻找新头指针指向的节点的key，这里**分三种**情况，
    - 没有对应的key，那创建新节点
    - 如果有对应key并且是相同的节点，把新节点patch到旧节点
    - 如果有对应key但是不是相同的节点，那也创建新节点

- 循环结束后，两个数组中可能存在没有遍历完的情况
  - 如新数组没遍历完，则添加新数组中漏掉的节点
  - 如旧数组没遍历完，则删除旧数组中漏掉的节点

### MVVM是什么

- 概述
  - MVVM是`Model-View-ViewModel`的缩写，分为三层
  - Model层主要是提供**数据模型**；
  - View层则是的提供**视图模板**，定义**结构布局**，展示**数据状态**，做了数据和事件的**绑定声明**，**指令声明**；
  - ViewModel是**View**和**Model**层的**桥梁**，数据绑定在ViewModel层会自动将数据渲染到页面，双向绑定的视图变化的时候也会通知ViewModel层更新数据。
- 优点
  - **分离**视图和模型，**降低**代码耦合，**提高**视图和逻辑复用
  - **双向绑定DOM**自动更新，开发者不用手动操作DOM
  - 便于**测试**
- 缺点
  - BUG难调试，双向绑定导致BUG**难以定位**错误发生在View层还是Model层。
  - 大型应用维护数据多，ViewModel构建维护成本会增大，Model层的数据长期持有也会大量占用内存。

### Vue的生命周期

- beforeCreate：当前阶段data、methods、computed以及watch上的数据和方法**都不可访问**。
- created：发生在实例创建后，这时候已**完成数据监测**，可**使用和获取**数据，但**无法与DOM交互**。
- beforeMount：发生在DOM挂载前，这时候**虚拟DOM已创建完成**，**即将开始渲染**。
- mounted：发生在DOM挂载后，数据**完成双向绑定**，**可访问DOM**。
- beforeUpdate：发生在响应式数据更新前，这时候虚拟DOM还没有重新渲染，还**可以更改数据**。
- updated：发生在数据更新后，**不能在此更改数据**，可能会导致**死循环**。
- beforeDestroy：发生在组件销毁前，可进行**收尾工作**，比如清除定时器。
- destroyed：发生在组件销毁后，只剩下DOM空壳，**数据绑定**和**监听**都被移除，**子组件**也被销毁。

### Vue的通信方式

1. `props/$emit+v-on`，通过props将数据自上而下传递，通过$emit和v-on向上传递；
2. 通过`EventBus`进行信息的发布订阅，利用vue实例的$emit和$on
3. 使用`vuex`，全局状态管理
4. 使用`$attrs/$listeners`，配置v-bind="$attrs"获取在父中定义的所有属性，配置v-on="$listeners"获取子中发布的所有事件
5. 使用`ref`可在父中访问子实例
6. 使用`$children/$parent`访问实例
7. 使用`provide/inject`，父通过provide提供变量，子通过inject注入变量，不管多深，但数据是非响应式的。
8. `localStorage/sessionStorage`

### computed和watch的区别

- computed是依赖于一个或多个属性，然后改变指定的属性值，有缓存性，只有依赖的属性发生改变才重新计算，常用于格式化数据
- watch是监听一个属性的变化而做一系列操作，比如要调ajax请求。

### Vue如何实现双向绑定的

- 采用**数据劫持**结合**发布订阅**模式，通过**Object.defineProperty()**来**劫持**数据对象各属性的**setter、getter**，在**数据变动**时**发布消息**给订阅者，**触发**相应监听**回调**。
- 具体实现
  - 实现一个数据监听器`Observer`，能够对数据对象各属性进行监听，如有变动获取最新值，通知订阅者；
  - 实现一个指令解析器`Compile`，对每个元素节点的指令进行扫描解析，根据指令模板替换数据，以及绑定相应的更新函数；
  - 实现一个`Watcher`，作为连接`Observer`和`Compile`的桥梁，能够订阅并收到属性变动通知，执行指令绑定的相应回调，从而更新视图；
  - 最后实现一个`MVVM`入口，用来接收数据对象，指定视图模板，调度`Observer`，`Compile`和`Watcher`。

### v-model的原理

- `v-model`本质是`value + input`方法的语法糖。可以通过model属性的`prop`和`event`属性来进行自定义。原生的v-model，会根据标签的不同生成不同的事件和属性。

### Vue事件绑定原理

- 原生事件绑定是通过`addEventListener`绑定给真实元素的，组件事件绑定是通过Vue自定义的`$on`实现的。

### Vue的模版编译原理

- Vue的编译过程就是将`template`转化为`render`函数的过程，主要分三步：
  1. 通过**解析器**，将**模板**转成**抽象语法树**（AST)；
  2. 通过**优化器**，对**AST**进行**静态节点标记**，主要用来做**虚拟DOM的渲染优化**；
  3. 通过**代码生成器**，将**AST**转成**render函数代码字符串**。

### Proxy相对于Object.defineProperty的优势

1. 可以直接监听**对象而非属性**，不用再遍历对象的属性
2. 可以直接监听**数组**的变化
3. 有多达**13**种拦截方法
4. 返回一个**新对象**，可以只操作新对象达到目的
5. 作为**新标准**，受到浏览器厂商重点持续的性能优化

### Vue中是如何检测数组变化

使用了**数据劫持**的方式，将数组操作的**7个方法**进行了**原型链重写**，指向了**自己定义**的数组方法，其实就是先调用了数组原本的方法，然后**添加通知依赖更新**的代码。这样当调用数组api时，就可以检测数组变化。如果数组中**包含**着**引用类型**，还会对数组中的引用类型**再次递归遍历**进行监控。

### Vue的key有什么用

- key是vue中虚拟DOM唯一标识，通过这个key，diff操作可以更准确，更快速。
- diff算法过程中，先会进行新旧节点的首尾交叉对比，当无法匹配的时候会用新节点的key与旧节点的key进行对比，然后查出差异。
- （准确）如果**不加key**，vue会选择**复用节点**，导致旧节点的**状态被保留**下来，产生一系列BUG
- （快速）key是唯一的，查找一个节点**不需要遍历**，因此更快速。

### nextTick的实现原理

在下次 DOM 更新循环结束之后执行延迟回调。nextTick主要使用了微任务，特殊情况会使用宏任务。根据执行环境分别尝试采用

- `Promise`(微)
- `MutationObserver`（微）
- `setImmediate`（宏）
- `MessageChannel`（宏）
- `如果以上都不行则采用setTimeout`（宏）

它定义了一个异步方法，多次调用nextTick会将方法存入队列中，通过这个异步方法清空当前队列。

### keep-alive的作用

- `keep-alive`可以实现组件**缓存**，当组件切换时**不会**对当前组件进行**卸载**。
- 常用的两个属性`include/exclude`，允许设置只对哪些组件进行缓存。
- 两个生命周期钩子`activated/deactivated`，分别在组件**激活**和**休眠**时触发。

### Vuex的原理

### Vue-Router的原理



## 手写与算法

### 实现类的继承

### 实现new

### 实现Object.create

### 实现instanceOf

### 实现call、apply和bind

### 实现防抖节流

### 实现deepClone

### 实现Promise

### 实现事件订阅发布

### 实现类型判断方法的封装 

### 排序算法

## 浏览器、HTTP和前端安全

### 从浏览器地址栏输入url到显示页面的步骤

1. 在浏览器地址栏输入URL
2. 浏览器查看缓存，如果请求资源在缓存中并且新鲜，跳转到转码步骤
   1. 如果资源未缓存，发起新请求
   2. 如果已缓存，检验是否足够新鲜，足够新鲜直接提供给客户端，否则与服务器进行验证。
   3. 检验新鲜通常有两个HTTP头进行控制`Expires`和`Cache-Control`：
      - HTTP1.0提供Expires，值为一个绝对时间表示缓存新鲜日期
      - HTTP1.1增加了Cache-Control: max-age=,值为以秒为单位的最大新鲜时间
3. 浏览器**解析URL**获取协议，主机，端口，path
4. 浏览器**组装一个HTTP（GET）请求报文**
5. 浏览器获取主机ip地址，过程如下：
   1. 浏览器缓存
   2. 本机缓存
   3. hosts文件
   4. 路由器缓存
   5. ISP DNS缓存
   6. DNS递归查询（可能存在负载均衡导致每次IP不一样）
6. 打开一个socket与目标IP地址，端口建立TCP链接，三次握手如下：
   1. 客户端发送一个TCP的**SYN=1，Seq=X**的包到服务器端口
   2. 服务器发回**SYN=1， ACK=X+1， Seq=Y**的响应包
   3. 客户端发送**ACK=Y+1， Seq=Z**
7. TCP链接建立后**发送HTTP请求**
8. 服务器接受请求并解析，将请求转发到服务程序，如虚拟主机使用HTTP Host头部判断请求的服务程序
9. 服务器检查**HTTP请求头是否包含缓存验证信息**如果验证缓存新鲜，返回**304**等对应状态码
10. 处理程序读取完整请求并准备HTTP响应，可能需要查询数据库等操作
11. 服务器将**响应报文通过TCP连接发送回浏览器**
12. 浏览器接收HTTP响应，然后根据情况选择关闭TCP连接或者保留重用，关闭TCP连接的四次握手如下：
    1. 主动方发送**Fin=1， Ack=Z， Seq= X**报文
    2. 被动方发送**ACK=X+1， Seq=Z**报文
    3. 被动方发送**Fin=1， ACK=X， Seq=Y**报文
    4. 主动方发送**ACK=Y， Seq=X**报文
13. 浏览器检查响应状态吗：是否为1XX，3XX， 4XX， 5XX，这些情况处理与2XX不同
14. 如果资源可缓存，**进行缓存**
15. 对响应进行**解码**（例如gzip压缩）
16. 根据资源类型决定如何处理（假设资源为HTML文档）
17. **解析HTML文档，构件DOM树，下载资源，构造CSSOM树，执行js脚本**，这些操作没有严格的先后顺序，以下分别解释
18. 构建DOM树：
    1. **Tokenizing**：根据HTML规范将字符流解析为标记
    2. **Lexing**：词法分析将标记转换为对象并定义属性和规则
    3. **DOM construction**：根据HTML标记关系将对象组成DOM树
19. 解析过程中遇到图片、样式表、js文件，**启动下载**
20. 构建CSSOM树：
    1. **Tokenizing**：字符流转换为标记流
    2. **Node**：根据标记创建节点
    3. **CSSOM**：节点创建CSSOM树
21. 根据DOM树和CSSOM树构建渲染树:
    1. 从DOM树的根节点遍历所有**可见节点**，不可见节点包括：1）`script`,`meta`这样本身不可见的标签。2)被css隐藏的节点，如`display: none`
    2. 对每一个可见节点，找到恰当的CSSOM规则并应用
    3. 发布可视节点的内容和计算样式
22. js解析如下：
    1. 浏览器创建Document对象并解析HTML，将解析到的元素和文本节点添加到文档中，此时**document.readystate为loading**
    2. HTML解析器遇到**没有`async`和`defer`的`script`时**，将他们添加到文档中，然后执行行内或外部脚本。这些脚本会同步执行，并且在脚本下载和执行时解析器会暂停。这样就可以用`document.write()`把文本插入到输入流中。**同步脚本经常简单定义函数和注册事件处理程序，他们可以遍历和操作script和他们之前的文档内容**
    3. 当解析器遇到设置了**`async`**属性的script时，开始下载脚本并继续解析文档。脚本会在它**下载完成后尽快执行**，但是**解析器不会停下来等它下载**。异步脚本**禁止使用`document.write()`**，它们可以访问自己script和之前的文档元素
    4. 当文档完成解析，`document.readState`变成interactive
    5. 所有`defer`脚本会**按照在文档出现的顺序执行**，延迟脚本**能访问完整文档树**，禁止使用`document.write()`
    6. 浏览器**在Document对象上触发`DOMContentLoaded`事件**
    7. 此时文档完全解析完成，浏览器可能还在等待如图片等内容加载，等这些**内容完成载入并且所有异步脚本完成载入和执行**，`document.readState`变为complete，window触发load事件
23. **显示页面**（HTML解析过程中会逐步显示页面）

### 浏览器渲染过程

### onload、DOMContentLoaded事件的触发顺序

1. 当onload事件触发时，页面上所有的DOM，样式表，脚本，图片等都已经加载好了。
2. 当DOMContentLoaded事件触发时，只有DOM加载完成。

### DOM Tree是如何构建的

### 浏览器回流和重绘的区别

### 什么是同源策略，如何实现跨域

### 实现即时通讯的方式

1. 短轮询
2. comet技术
3. Server Send Event
4. WebSocket

### 什么是HTTP

HTTP是超文本传输协议（Hyper Text Transfer Protocol）是一种通信协议，它允许将超文本标记语言（HTML)文档从WEB服务器传送到客户端的浏览器。HTTP协议是构建在TCP/IP协议之上的，是TCP/IP协议的一个子集。

### HTTP有哪些方法

1. GET， 获取资源
2. POST ，发送数据
3. OPTIONS， 查看资源支持什么方法请求
4. HEAD， 获取请求资源的头部信息，如在下载大文件前先获取大小，再决定是否下载
5. PUT， 新增或更新资源
6. DELETE，删除资源
7. PATCH，局部修改资源
8. CONNECT， 把请求连接转换成透明的TCP/IP通道
9. TRACE， 用来激发一个远程的应用层的请求消息回路

### GET/POST POST/PUT PUT/PATCH的区别

- GET/POST区别：
  - 数据传输方式不同
  - 安全性不同
  - 数据类型不同
  - 特性不同
- PUT/POST区别：PUT是更新资源PUT幂等，POST是提交资源POST非幂等
- PUT/PATCH的区别：都是更新资源，PATCH可对资源进行局部更新

### HTTP报文

- 请求报文：
  - 请求行，包括请求方法，URL和HTTP协议版本号
  - 请求头，由键值对组成，每行一对，冒号分隔
  - 空行
  - 请求体，post put等方法携带的数据
- 响应报文
  - 响应行，包括HTTP协议版本，状态码和状态码短语
  - 响应头，由键值对组成，每行一对，冒号分隔
  - 空行
  - 响应体，服务器返回的数据

### HTTP首部

- 通用首部
- 请求首部
- 响应首部
- 实体首部
- 常见

### HTTP的keep-alive是干什么的

在早期HTTP/1.0版本，每一次HTTP请求都要建立一个连接，创建连接需要消耗资源和时间，为了减少资源消耗缩短时间，就需要重用连接。在HTTP请求头中加入Connection:keep-alive就可以告诉对方这个请求响应完成后不要关闭连接，下次还用这个请求继续交流。
优点：

1. 由于打开的连接少了，CPU和内存的使用会减少

2. 允许请求和应答的HTTP管线化
3. 降低拥塞控制
4. 减少后续请求的延迟
5. 报告错误无需关闭TCP连接

### HTTP状态码

- 1xx
- 2xx
- 3xx
- 4xx
- 5xx

### 说说HTTPS

- HTTP协议数据都是明文进行传输的，缺乏安全性，而HTTPS就是为了解决HTTP的不安全的问题。
- HTTPS如何保证安全？
  - 先解释一下对称加密和非对称加密。
  - 对称加密是使用同一个密钥进行加解密。在通信过程中，先把密钥发送给对方，把加密后内容发给对方，然后对方使用密钥解密。
  - 非对称加密则是有一个密钥对，公钥和私钥，公钥加密私钥解密，或者私钥加密公钥解密。在通信过程中，把自己的公钥发送给对方，对方使用公钥加密后把加密内容返回，然后用自己的私钥解密。
  - HTTPS则是结合这两种加密方式，将对称加密的密钥使用非对称加密的公钥加密，然后发送出去，接收方使用私钥解密，得到对称加密的密钥，然后双方可以使用对称加密进行沟通。
  - 但这样仍存在问题，即中间人可以在一开始发送公钥的时候，把公钥换成自己的公钥，这样就可以用自己的私钥来解密。
  - 这时就需要一个安全的第三方颁发的证书，证明发送方的身份，防止被中间人攻击。
  - 服务器会把带有自己公钥的这个第三方颁发的证书发送给客户端，客户端可以通过证书上的信息对发送方的身份进行验证，如果验证通过，说明这个公钥是可靠安全的。
  - 具体验证方式：证书颁发机构会先用证书指定的HASH算法对证书内容进行HASH得到摘要，再用机构自己的私钥加密，组成数字签名，然后得到签署了数字签名和服务器公钥的证书，服务器将这个证书发给客户端，客户端使用机构的公钥对数字签名进行解密得到摘要，然后使用证书上的HASH算法对内容进行HASH也得到摘要，对比两个摘要就知道中间是否被篡改。

### 说说HTTP2

相对于HTTP1有以下优势 ：

1. 二进制分帧，HTTP2采用二进制格式传输数据，而非HTTP1的文本格式，解析更高效
2. 头部压缩
3. 服务器推送
4. 多路复用

### 说说HTTP缓存

- 使用HTTP缓存的过程
  - 先根据这个资源的一些 http header 判断它是否命中强缓存，如果命中，则直接从本地获取缓存资源，不会发请求到服务器；
  - 当强缓存没有命中时，客户端会发送请求到服务器，服务器通过另一些request header验证这个资源是否命中协商缓存，称为http再验证，如果命中，服务器将请求返回，但不返回资源，而是告诉客户端直接从缓存中获取，客户端收到返回后就会从缓存中获取资源；
  - 强缓存和协商缓存共同之处在于，如果命中缓存，服务器都不会返回资源； 区别是，强缓存不对发送请求到服务器，但协商缓存会。
  - 当协商缓存也没命中时，服务器就会将资源发送回客户端。
  - 当 ctrl+f5 强制刷新网页时，直接从服务器加载，跳过强缓存和协商缓存；
  - 当 f5刷新网页时，跳过强缓存，但是会检查协商缓存
- 强缓存
  - Expires（该字段是 http1.0 时的规范，值为一个绝对时间的 GMT 格式的时间字符串，代表缓存资源的过期时间）
  - Cache-Control:max-age（该字段是 http1.1的规范，强缓存利用其 max-age 值来判断缓存资源的最大生命周期，它的值单位为秒）
- 协商缓存
  - Last-Modified（值为资源最后更新时间，随服务器response返回）
  - If-Modified-Since（通过比较两个时间来判断资源在两次请求期间是否有过修改，如果没有修改，则命中协商缓存）
  - ETag（表示资源内容的唯一标识，随服务器response返回）
  - If-None-Match（服务器通过比较请求头部的If-None-Match与当前资源的ETag是否一致来判断资源是否在两次请求之间有过修改，如果没有修改，则命中协商缓存）

### 说说TCP和UDP

### 说说TCP的三次握手和四次挥手

### WEBSOCKET握手过程

### 前端安全问题

1. XSS
2. CSRF

## 前端工程化和优化



### 首屏优化

### 怎么做前端优化？

1. 网页内容
   - 减少HTTP请求次数
   - 减少DNS查询次数
   - 避免页面跳转
   - AJAX缓存
   - 懒加载
   - 提前加载
   - 减少DOM元素数量
   - 根据域名划分内容
   - 减少iframe数量
2. 服务器
   - 使用CDN
   - 添加Expires或者Cache Control报文头
   - Gzip压缩文件
   - 配置Etags
   - 尽早flush输出
   - 使用ajax
   - 避免空的图片src
3. Cookie
   - 减少Cookie大小
   - 页面内容使用无Cookie域名
4. CSS
   - 样式表置顶
   - 避免CSS表达式
   - 代替@import
   - 避免使用Filters
5. JS
   - 脚本置底
   - 使用外部js和CSS文件
   - 精简JS和CSS
   - 去除重复脚本
   - 减少DOM操作
   - 使用事件代理
6. 图片
   - 优化图片
   - 使用雪碧图
   - 不要在HTML中缩放图片
   - 使用小且可缓存的ico