---
sidebar: auto
---

# 前端面试题

## HTML

### SEO

### HTML5

## CSS

### BFC

### 层叠上下文

## Javascript

### 原型和原型链

1. 构建**函数**的 prototype->函数创建的**实例**的原型->实例的`__proto__`
2. 原型对象的 `constructor` 属性->构造函数本身
3. `Person.prototype === person1.__proto__`
4. 特点
   - 原型对象上添加属性，实例会共享这些属性
   - 在对象查找自身没有的属性时，会从对象的原型上找，找不到就找原型的原型，一直找到 Object.prototype，还找不到返回 null
5. 原型链就是查找对象查找属性时所途径的链式结构。

### 作用域和作用域链

1. 作用域：代码**定义变量**的区**域**。有一套**规则**，规定了**如何查找**变量，确定当前执行代码对变量的**访问权限**。
2. 分类：全局、函数和 eval 作用域。
3. 特点：JS 是**静态作用域**，函数的作用域在函数创建的时候就已确定。
4. 规则：作用域可**嵌套**，在查找变量时，先从当前作用域中查找，找不到就在外层的作用域中找，直至全局作用域，然后停止查找。
5. 作用域链：**逐层嵌套**的作用域构成的链表结构就是作用域链。

### 闭包

1.  怎么产生闭包
    - 函数嵌套，内函数引用了外函数的变量
2.  什么是闭包
    - 两种理解。
    - 内函数。
    - 包含引用变量的对象，chrome debugger scope 中的 closure。
3.  闭包的作用
    - 延长生命
    - 外部可用(突破作用域)
4.  闭包的缺点
    - 变量未释放->占内存
    - 滥用->内存泄漏

### this 的指向

1. 默认情况，非严格模式，this 指向全局对象
2. 在函数中 this 一般指向调用该函数的对象
3. 使用 call,apply,bind 方法可显式指定 this 的指向
4. 使用 new 调用构造函数，函数中的 this 指向新创建的实例对象
5. 箭头函数没有自己的 this，函数中的 this 指向箭头函数所在的上下文中的 this

### js 执行机制

1. 执行上下文
2. 执行上下文栈
3. 执行上下文如何创建？
   - 确定this指向
   - 创建词法环境
     - 环境记录
     - 对外部环境的引用
   - 创建变量环境

### js 中有哪些类型

答：8 种，undefined、null、number、string、boolean、symbol、bigInt、object。

### null 与 undefined 的区别

- undefined 表示变量声明了**未赋值**。
- null 赋值了，值为空，表示变量未来可能指向一个对象，可用于**主动释放** 对象的引用。

### == 和 === 的区别

- === 判断类型和值是否相同，对象比较的是地址值。
- == 类型相同，同===，不同会做隐式类型转换，具体判断流程如下：
  - 判断类型，相同则使用===，不相同，做类型转换
  - 判断是否对比 null 和 undefined，是就返回 true
  - 判断是否对比 string 和 number，是就将 string 转成 number 再比较
  - 判断其中一方是否为 boolean，是就将 boolean 转成 number 再比较
  - 判断其中一方是否为 object，且另一方为 string，number，symbol，是就把 object 转成原始类型。

### 为什么会有bigint提案

- js所有数字都保存成64位浮点数，这给数值的表示带来两大限制。
  - 一是数值的精度只能到53个二进制位（相当于16个十进制位），大于这个范围的整数，js无法精确表示，不适合科学和金融方面的精确计算。
  - 二是大于或等于2的1024次方的数值，js无法表示，会返回Infinity。
- bigInt就是用来解决这个问题的，只能用来表示整数，没有位数限制，任何位数的整数都能精确表示。为了与Number类型区别，bigInt必须添加后缀n。

### 为什么0.1+0.2!=0.3

- js中的数字是用64位二进制表示的
  - 其中第1位是符号位；
  - 2到12位，共11位是指数部分；
  - 第13到64位，共52位是小数部分，如果小数部分超过52位就会0舍1入保留52位，导致精度丢失。
- 0.1用二进制表示时，小数部分是1001无限循环，13次1001就占了52位，第53位是1，0舍1入舍去，最后4位最终会变成1010，这样肯定就比0.1大了。0.2也类似，最终相加实际比0.3大。

### 变量提升和函数提升

- 变量提升：var声明的变量，在声明前就可以访问，此时变量值为undefined。
- 函数提升：用function声明函数，在声明前就可以直接调用。
- 先执行变量提升，再执行函数提升。
- let和const有临时性区区的特性，必须声明才能使用，否则报错。

### ES6模块与CommonJS模块的区别

- 两大差异
  - CommonJS模块输出的是一个值的拷贝，加载模块后，在模块内改变值不会影响到输出值；ES6模块输出的是值的引用，模块内的输出值变了，会影响到引用它的地方。
  - CommonJS模块是运行时加载，ES6模块是编译时输出接口。

### V8 垃圾回收机制

- V8将内存堆分为新生代和老生代。
- 新生代中的对象存活时间较短，使用Scavenge算法。在新生代空间中，内存空间分为两部分，from空间和to空间。一个空间是使用的，另一个空间是空闲的。新分配的对象会被放入From空间中，当From空间占满时，新生代算法就会启动进行垃圾回收。该算法会检查from空间中存活的对象，判断对象是否符合晋升条件，如果符合就晋升成老生代，否则将对象复制到To空间中，如果有失活的对象就会销毁。当复制完成后将from空间和to空间互换，这样垃圾回收就结束了。
- 老生代中的对象存活时间较长，会使用两个算法，即**标记清除算法**和**标记压缩算法**。在Scavenge算法中，有些对象会因符合某些条件被移到老生代空间中，比如经历过一次Scavenge算法的对象，或者To空间对象占比大小超25%。
- 老生代中的**标记清除算法**故名思义，遍历堆中所有对象，将存活对象标记出来，然后对未标记的对象空间进行回收。
- 但经过标记清除后，会造成堆内存出现碎片的情况，当碎片超过一定限制后就会启动**标记压缩算法**，将活的对象向一端移动，直到所有对象都移动到一边，然后清理掉不需要的内存。

### 事件循环

- js 中有一个**主线程**，一个**调用栈**，和独立于调用栈的消息队列，可分宏任务队列和微任务队列
- 宏任务：script 代码，setTimeout/setInterval/setImmediate, I/O, UI rendering
- 微任务：process.nextTick, Promise, Object.observe, MutationObserver
- 代码执行过程中，将任务的各自回调函数根据任务类型放入对应的任务队列中
- 主执行栈清空，依次执行微任务队列中的任务，微任务队列清空后，再执行宏任务队列中的下一个任务

### JS异步方式

- 回调函数
- promise
- generator
- async/await

## Vue相关

### 虚拟DOM

### diff原理

### MVVM原理

### 响应式数据的原理

初始化数据->

### Vue中是如何检测数组变化



### 怎么实现vue的minin方法

### Vuex的原理

### Vue-Router的原理

## 手写与算法

### 实现类的继承

### 实现new

### 实现Object.create

### 实现instanceOf

### 实现call、apply和bind

### 实现防抖节流

### 实现deepClone

### 实现Promise

### 实现事件订阅发布

### 实现类型判断方法的封装 

### 排序算法

## 浏览器、HTTP和前端安全

### 浏览器渲染过程

### onload、DOMContentLoaded事件的触发顺序

1. 当onload事件触发时，页面上所有的DOM，样式表，脚本，图片等都已经加载好了。
2. 当DOMContentLoaded事件触发时，只有DOM加载完成。

### WEBSOCKET握手过程

### 前端安全问题

## 前端工程化和优化

### 首屏优化